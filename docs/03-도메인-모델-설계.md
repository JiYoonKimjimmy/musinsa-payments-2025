# 03. 도메인 모델 설계

## 1. 개요

헥사고날 아키텍처 기반으로 도메인 모델을 설계합니다. 도메인 중심 설계(DDD) 원칙을 적용하여 비즈니스 로직이 도메인 모델에 집중되도록 합니다.

## 2. 도메인 모델 구조

### 2.1 패키지 구조

```
com.musinsa.payments.point.domain
├── entity          # 도메인 엔티티
├── valueobject     # 값 객체
├── repository      # 리포지토리 인터페이스 (포트)
├── service         # 도메인 서비스
└── exception       # 도메인 예외
```

## 3. 엔티티 설계

### 3.1 Member (사용자)

```java
package com.musinsa.payments.point.domain.entity;

public class Member {
    private Long id;
    private String memberNo;
    private String name;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // 비즈니스 메서드
    public boolean isSameMember(Long memberId) {
        return this.id.equals(memberId);
    }
}
```

**책임**:
- 사용자 정보 관리
- 사용자 식별

### 3.2 PointAccumulation (포인트 적립)

```java
package com.musinsa.payments.point.domain.entity;

public class PointAccumulation {
    private Long id;
    private String pointKey;
    private Long memberId;
    private Money amount;              // 값 객체
    private Money availableAmount;    // 값 객체
    private LocalDate expirationDate;
    private boolean isManualGrant;
    private PointAccumulationStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // 비즈니스 메서드
    public boolean canBeCancelled() {
        return status == PointAccumulationStatus.ACCUMULATED 
            && availableAmount.equals(amount);
    }
    
    public boolean isExpired() {
        return LocalDate.now().isAfter(expirationDate);
    }
    
    public boolean isExpiredAt(LocalDate date) {
        return date.isAfter(expirationDate);
    }
    
    public void use(Money usageAmount) {
        if (availableAmount.isLessThan(usageAmount)) {
            throw new InsufficientPointException();
        }
        this.availableAmount = availableAmount.subtract(usageAmount);
    }
    
    public void cancel() {
        if (!canBeCancelled()) {
            throw new CannotCancelAccumulationException();
        }
        this.status = PointAccumulationStatus.CANCELLED;
    }
    
    public void markAsExpired() {
        this.status = PointAccumulationStatus.EXPIRED;
    }
    
    public boolean isManualGrant() {
        return isManualGrant;
    }
    
    public boolean hasAvailableAmount() {
        return availableAmount.isGreaterThan(Money.ZERO);
    }
}
```

**책임**:
- 포인트 적립 정보 관리
- 적립 취소 가능 여부 판단
- 만료 여부 확인
- 포인트 사용 처리
- 상태 관리

### 3.3 PointUsage (포인트 사용)

```java
package com.musinsa.payments.point.domain.entity;

public class PointUsage {
    private Long id;
    private String pointKey;
    private Long memberId;
    private OrderNumber orderNumber;  // 값 객체
    private Money totalAmount;        // 값 객체
    private Money cancelledAmount;    // 값 객체
    private PointUsageStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // 비즈니스 메서드
    public Money getRemainingAmount() {
        return totalAmount.subtract(cancelledAmount);
    }
    
    public boolean canCancel(Money cancelAmount) {
        return getRemainingAmount().isGreaterThanOrEqual(cancelAmount);
    }
    
    public void cancel(Money cancelAmount) {
        if (!canCancel(cancelAmount)) {
            throw new CannotCancelUsageException();
        }
        this.cancelledAmount = cancelledAmount.add(cancelAmount);
        updateStatus();
    }
    
    private void updateStatus() {
        if (cancelledAmount.equals(totalAmount)) {
            this.status = PointUsageStatus.FULLY_CANCELLED;
        } else if (cancelledAmount.isGreaterThan(Money.ZERO)) {
            this.status = PointUsageStatus.PARTIALLY_CANCELLED;
        }
    }
}
```

**책임**:
- 포인트 사용 정보 관리
- 사용 취소 처리
- 상태 관리

### 3.4 PointUsageDetail (포인트 사용 상세)

```java
package com.musinsa.payments.point.domain.entity;

public class PointUsageDetail {
    private Long id;
    private Long pointUsageId;
    private Long pointAccumulationId;
    private Money amount;             // 값 객체
    private Money cancelledAmount;    // 값 객체
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // 비즈니스 메서드
    public Money getRemainingAmount() {
        return amount.subtract(cancelledAmount);
    }
    
    public void cancel(Money cancelAmount) {
        if (getRemainingAmount().isLessThan(cancelAmount)) {
            throw new CannotCancelDetailException();
        }
        this.cancelledAmount = cancelledAmount.add(cancelAmount);
    }
    
    public boolean isFullyCancelled() {
        return cancelledAmount.equals(amount);
    }
}
```

**책임**:
- 1원 단위 포인트 사용 추적
- 사용 상세 취소 처리

### 3.5 PointConfig (포인트 설정)

```java
package com.musinsa.payments.point.domain.entity;

public class PointConfig {
    private Long id;
    private String configKey;
    private String configValue;
    private String description;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // 비즈니스 메서드
    public Long getLongValue() {
        return Long.parseLong(configValue);
    }
    
    public Integer getIntValue() {
        return Integer.parseInt(configValue);
    }
    
    public boolean getBooleanValue() {
        return Boolean.parseBoolean(configValue);
    }
}
```

**책임**:
- 동적 설정 값 관리
- 설정 값 타입 변환

### 3.6 PointCancellation (포인트 취소)

```java
package com.musinsa.payments.point.domain.entity;

public class PointCancellation {
    private Long id;
    private String pointKey;
    private CancellationType cancellationType;
    private String targetPointKey;
    private Long memberId;
    private Money amount;             // 값 객체
    private String reason;
    private LocalDateTime createdAt;
}
```

**책임**:
- 취소 정보 기록
- 취소 이력 관리

## 4. 값 객체 (Value Object) 설계

### 4.1 Money (금액)

```java
package com.musinsa.payments.point.domain.valueobject;

public class Money {
    public static final Money ZERO = new Money(0);
    
    private final BigDecimal amount;
    
    private Money(BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("금액은 0 이상이어야 합니다.");
        }
        this.amount = amount.setScale(0, RoundingMode.DOWN);
    }
    
    public static Money of(long amount) {
        return new Money(BigDecimal.valueOf(amount));
    }
    
    public static Money of(BigDecimal amount) {
        return new Money(amount);
    }
    
    public Money add(Money other) {
        return new Money(this.amount.add(other.amount));
    }
    
    public Money subtract(Money other) {
        return new Money(this.amount.subtract(other.amount));
    }
    
    public boolean isGreaterThan(Money other) {
        return this.amount.compareTo(other.amount) > 0;
    }
    
    public boolean isGreaterThanOrEqual(Money other) {
        return this.amount.compareTo(other.amount) >= 0;
    }
    
    public boolean isLessThan(Money other) {
        return this.amount.compareTo(other.amount) < 0;
    }
    
    public boolean isLessThanOrEqual(Money other) {
        return this.amount.compareTo(other.amount) <= 0;
    }
    
    public boolean equals(Money other) {
        return this.amount.compareTo(other.amount) == 0;
    }
    
    public long toLong() {
        return amount.longValue();
    }
    
    public BigDecimal toBigDecimal() {
        return amount;
    }
}
```

**특징**:
- 불변 객체 (Immutable)
- 값 비교는 amount로 수행
- 금액 연산 메서드 제공

### 4.2 OrderNumber (주문번호)

```java
package com.musinsa.payments.point.domain.valueobject;

public class OrderNumber {
    private final String value;
    
    private OrderNumber(String value) {
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("주문번호는 필수입니다.");
        }
        this.value = value;
    }
    
    public static OrderNumber of(String value) {
        return new OrderNumber(value);
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OrderNumber that = (OrderNumber) o;
        return Objects.equals(value, that.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
}
```

**특징**:
- 불변 객체
- 주문번호 검증 로직 포함

### 4.3 PointKey (포인트 키)

```java
package com.musinsa.payments.point.domain.valueobject;

public class PointKey {
    private final String value;
    
    private PointKey(String value) {
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("포인트 키는 필수입니다.");
        }
        this.value = value;
    }
    
    public static PointKey of(String value) {
        return new PointKey(value);
    }
    
    public static PointKey generate() {
        // UUID 또는 시퀀스 기반 생성
        return new PointKey(UUID.randomUUID().toString().substring(0, 8).toUpperCase());
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PointKey pointKey = (PointKey) o;
        return Objects.equals(value, pointKey.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
}
```

**특징**:
- 불변 객체
- 포인트 키 생성 로직 포함

## 5. Enum 설계

### 5.1 PointAccumulationStatus

```java
package com.musinsa.payments.point.domain.entity;

public enum PointAccumulationStatus {
    ACCUMULATED,  // 적립됨
    CANCELLED,    // 취소됨
    EXPIRED       // 만료됨
}
```

### 5.2 PointUsageStatus

```java
package com.musinsa.payments.point.domain.entity;

public enum PointUsageStatus {
    USED,                  // 사용됨
    PARTIALLY_CANCELLED,   // 부분 취소됨
    FULLY_CANCELLED        // 전체 취소됨
}
```

### 5.3 CancellationType

```java
package com.musinsa.payments.point.domain.entity;

public enum CancellationType {
    ACCUMULATION_CANCELLATION,  // 적립 취소
    USAGE_CANCELLATION          // 사용 취소
}
```

## 6. 도메인 서비스 설계

### 6.1 PointAccumulationService

```java
package com.musinsa.payments.point.domain.service;

public class PointAccumulationService {
    
    public PointAccumulation createAccumulation(
            Long memberId,
            Money amount,
            LocalDate expirationDate,
            boolean isManualGrant,
            PointKeyGenerator pointKeyGenerator) {
        
        // 검증 로직
        validateAccumulationAmount(amount);
        validateExpirationDate(expirationDate);
        
        // PointAccumulation 생성
        return PointAccumulation.builder()
            .pointKey(pointKeyGenerator.generate())
            .memberId(memberId)
            .amount(amount)
            .availableAmount(amount)
            .expirationDate(expirationDate)
            .isManualGrant(isManualGrant)
            .status(PointAccumulationStatus.ACCUMULATED)
            .build();
    }
    
    private void validateAccumulationAmount(Money amount) {
        // 1원 이상 검증
        if (amount.isLessThan(Money.of(1))) {
            throw new InvalidAmountException("적립 금액은 1원 이상이어야 합니다.");
        }
    }
    
    private void validateExpirationDate(LocalDate expirationDate) {
        // 만료일 검증 로직
    }
}
```

**책임**:
- 포인트 적립 생성 로직
- 적립 관련 비즈니스 규칙 검증

### 6.2 PointUsagePriorityService

```java
package com.musinsa.payments.point.domain.service;

public class PointUsagePriorityService {
    
    public List<PointAccumulation> selectAccumulationsForUsage(
            Long memberId,
            Money usageAmount,
            List<PointAccumulation> accumulations) {
        
        // 사용 가능한 적립 건만 필터링
        List<PointAccumulation> available = accumulations.stream()
            .filter(PointAccumulation::hasAvailableAmount)
            .filter(acc -> !acc.isExpired())
            .collect(Collectors.toList());
        
        // 우선순위 정렬: 수기 지급 > 만료일 짧은 순
        available.sort(Comparator
            .comparing(PointAccumulation::isManualGrant).reversed()
            .thenComparing(PointAccumulation::getExpirationDate));
        
        // 사용할 적립 건 선택
        return selectAccumulations(available, usageAmount);
    }
    
    private List<PointAccumulation> selectAccumulations(
            List<PointAccumulation> accumulations,
            Money usageAmount) {
        
        List<PointAccumulation> selected = new ArrayList<>();
        Money remaining = usageAmount;
        
        for (PointAccumulation accumulation : accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break;
            }
            
            Money available = accumulation.getAvailableAmount();
            Money useAmount = remaining.isLessThan(available) 
                ? remaining 
                : available;
            
            selected.add(accumulation);
            remaining = remaining.subtract(useAmount);
        }
        
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw new InsufficientPointException();
        }
        
        return selected;
    }
}
```

**책임**:
- 포인트 사용 우선순위 결정
- 사용할 적립 건 선택

## 7. 도메인 예외 설계

### 7.1 도메인 예외 계층 구조

```java
package com.musinsa.payments.point.domain.exception;

// 기본 도메인 예외
public class PointDomainException extends RuntimeException {
    public PointDomainException(String message) {
        super(message);
    }
}

// 구체적인 예외들
public class InsufficientPointException extends PointDomainException {
    public InsufficientPointException() {
        super("사용 가능한 포인트가 부족합니다.");
    }
}

public class CannotCancelAccumulationException extends PointDomainException {
    public CannotCancelAccumulationException() {
        super("이미 사용된 포인트는 적립 취소할 수 없습니다.");
    }
}

public class CannotCancelUsageException extends PointDomainException {
    public CannotCancelUsageException() {
        super("취소할 수 없는 사용 건입니다.");
    }
}

public class InvalidAmountException extends PointDomainException {
    public InvalidAmountException(String message) {
        super(message);
    }
}

public class ExceededMaxBalanceException extends PointDomainException {
    public ExceededMaxBalanceException() {
        super("개인별 최대 보유 금액을 초과했습니다.");
    }
}
```

## 8. 리포지토리 인터페이스 (포트)

### 8.1 PointAccumulationRepository

```java
package com.musinsa.payments.point.domain.repository;

public interface PointAccumulationRepository {
    PointAccumulation save(PointAccumulation accumulation);
    Optional<PointAccumulation> findByPointKey(String pointKey);
    List<PointAccumulation> findByMemberId(Long memberId);
    List<PointAccumulation> findAvailableByMemberId(Long memberId);
    Money calculateTotalBalance(Long memberId);
    Money calculateAvailableBalance(Long memberId);
}
```

### 8.2 PointUsageRepository

```java
package com.musinsa.payments.point.domain.repository;

public interface PointUsageRepository {
    PointUsage save(PointUsage usage);
    Optional<PointUsage> findByPointKey(String pointKey);
    List<PointUsage> findByMemberId(Long memberId);
    List<PointUsage> findByOrderNumber(String orderNumber);
}
```

### 8.3 PointUsageDetailRepository

```java
package com.musinsa.payments.point.domain.repository;

public interface PointUsageDetailRepository {
    List<PointUsageDetail> saveAll(List<PointUsageDetail> details);
    List<PointUsageDetail> findByPointUsageId(Long pointUsageId);
    List<PointUsageDetail> findByPointAccumulationId(Long pointAccumulationId);
}
```

### 8.4 PointConfigRepository

```java
package com.musinsa.payments.point.domain.repository;

public interface PointConfigRepository {
    Optional<PointConfig> findByConfigKey(String configKey);
    PointConfig save(PointConfig config);
    List<PointConfig> findAll();
}
```

## 9. 다음 단계

다음 단계에서는 API 설계를 통해 REST 엔드포인트와 DTO를 정의할 예정입니다.

---

**다음 문서**: [04. API 설계](./04-API-설계.md)

