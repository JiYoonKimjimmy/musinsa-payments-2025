# 03. 도메인 모델 설계

## 1. 개요

헥사고날 아키텍처 기반으로 도메인 모델을 설계합니다. 도메인 중심 설계(DDD) 원칙을 적용하여 비즈니스 로직이 도메인 모델에 집중되도록 합니다.

## 2. 도메인 모델 구조

### 2.1 패키지 구조

```
com.musinsa.payments.point.domain
├── entity          # 도메인 엔티티
├── valueobject     # 값 객체
├── repository      # 리포지토리 인터페이스 (포트)
├── service         # 도메인 서비스
└── exception       # 도메인 예외
```

## 3. 엔티티 설계

### 3.1 Member (사용자)

```kotlin
package com.musinsa.payments.point.domain.entity

class Member {
    var id: Long? = null
    var memberNo: String? = null
    var name: String? = null
    var createdAt: LocalDateTime? = null
    var updatedAt: LocalDateTime? = null
    
    // 비즈니스 메서드
    fun isSameMember(memberId: Long): Boolean {
        return this.id == memberId
    }
}
```

**책임**:
- 사용자 정보 관리
- 사용자 식별

### 3.2 PointAccumulation (포인트 적립)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointAccumulation {
    var id: Long? = null
    var pointKey: String? = null
    var memberId: Long? = null
    var amount: Money? = null              // 값 객체
    var availableAmount: Money? = null    // 값 객체
    var expirationDate: LocalDate? = null
    var isManualGrant: Boolean = false
    var status: PointAccumulationStatus? = null
    var createdAt: LocalDateTime? = null
    var updatedAt: LocalDateTime? = null
    
    // 비즈니스 메서드
    fun canBeCancelled(): Boolean {
        return status == PointAccumulationStatus.ACCUMULATED 
            && availableAmount == amount
    }
    
    fun isExpired(): Boolean {
        return LocalDate.now().isAfter(expirationDate)
    }
    
    fun isExpiredAt(date: LocalDate): Boolean {
        return date.isAfter(expirationDate)
    }
    
    fun use(usageAmount: Money) {
        if (availableAmount?.isLessThan(usageAmount) == true) {
            throw InsufficientPointException()
        }
        availableAmount = availableAmount?.subtract(usageAmount)
    }
    
    fun cancel() {
        if (!canBeCancelled()) {
            throw CannotCancelAccumulationException()
        }
        status = PointAccumulationStatus.CANCELLED
    }
    
    fun markAsExpired() {
        status = PointAccumulationStatus.EXPIRED
    }
    
    fun isManualGrant(): Boolean {
        return isManualGrant
    }
    
    fun hasAvailableAmount(): Boolean {
        return availableAmount?.isGreaterThan(Money.ZERO) == true
    }
}
```

**책임**:
- 포인트 적립 정보 관리
- 적립 취소 가능 여부 판단
- 만료 여부 확인
- 포인트 사용 처리
- 상태 관리

### 3.3 PointUsage (포인트 사용)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointUsage {
    var id: Long? = null
    var pointKey: String? = null
    var memberId: Long? = null
    var orderNumber: OrderNumber? = null  // 값 객체
    var totalAmount: Money? = null        // 값 객체
    var cancelledAmount: Money? = null    // 값 객체
    var status: PointUsageStatus? = null
    var createdAt: LocalDateTime? = null
    var updatedAt: LocalDateTime? = null
    
    // 비즈니스 메서드
    fun getRemainingAmount(): Money? {
        return totalAmount?.subtract(cancelledAmount ?: Money.ZERO)
    }
    
    fun canCancel(cancelAmount: Money): Boolean {
        return getRemainingAmount()?.isGreaterThanOrEqual(cancelAmount) == true
    }
    
    fun cancel(cancelAmount: Money) {
        if (!canCancel(cancelAmount)) {
            throw CannotCancelUsageException()
        }
        cancelledAmount = (cancelledAmount ?: Money.ZERO).add(cancelAmount)
        updateStatus()
    }
    
    private fun updateStatus() {
        when {
            cancelledAmount == totalAmount -> {
                status = PointUsageStatus.FULLY_CANCELLED
            }
            cancelledAmount?.isGreaterThan(Money.ZERO) == true -> {
                status = PointUsageStatus.PARTIALLY_CANCELLED
            }
        }
    }
}
```

**책임**:
- 포인트 사용 정보 관리
- 사용 취소 처리
- 상태 관리

### 3.4 PointUsageDetail (포인트 사용 상세)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointUsageDetail {
    var id: Long? = null
    var pointUsageId: Long? = null
    var pointAccumulationId: Long? = null
    var amount: Money? = null             // 값 객체
    var cancelledAmount: Money? = null    // 값 객체
    var createdAt: LocalDateTime? = null
    var updatedAt: LocalDateTime? = null
    
    // 비즈니스 메서드
    fun getRemainingAmount(): Money? {
        return amount?.subtract(cancelledAmount ?: Money.ZERO)
    }
    
    fun cancel(cancelAmount: Money) {
        if (getRemainingAmount()?.isLessThan(cancelAmount) == true) {
            throw CannotCancelDetailException()
        }
        cancelledAmount = (cancelledAmount ?: Money.ZERO).add(cancelAmount)
    }
    
    fun isFullyCancelled(): Boolean {
        return cancelledAmount == amount
    }
}
```

**책임**:
- 1원 단위 포인트 사용 추적
- 사용 상세 취소 처리

### 3.5 PointConfig (포인트 설정)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointConfig {
    var id: Long? = null
    var configKey: String? = null
    var configValue: String? = null
    var description: String? = null
    var createdAt: LocalDateTime? = null
    var updatedAt: LocalDateTime? = null
    
    // 비즈니스 메서드
    fun getLongValue(): Long {
        return configValue?.toLongOrNull() 
            ?: throw IllegalArgumentException("configValue가 null이거나 숫자가 아닙니다.")
    }
    
    fun getIntValue(): Int {
        return configValue?.toIntOrNull() 
            ?: throw IllegalArgumentException("configValue가 null이거나 숫자가 아닙니다.")
    }
    
    fun getBooleanValue(): Boolean {
        return configValue?.toBoolean() ?: false
    }
}
```

**책임**:
- 동적 설정 값 관리
- 설정 값 타입 변환

### 3.6 PointCancellation (포인트 취소)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointCancellation {
    var id: Long? = null
    var pointKey: String? = null
    var cancellationType: CancellationType? = null
    var targetPointKey: String? = null
    var memberId: Long? = null
    var amount: Money? = null             // 값 객체
    var reason: String? = null
    var createdAt: LocalDateTime? = null
}
```

**책임**:
- 취소 정보 기록
- 취소 이력 관리

## 4. 값 객체 (Value Object) 설계

### 4.1 Money (금액)

```kotlin
package com.musinsa.payments.point.domain.valueobject

class Money private constructor(rawAmount: BigDecimal) {
    companion object {
        val ZERO = Money(BigDecimal.ZERO)
        
        fun of(amount: Long): Money {
            return Money(BigDecimal.valueOf(amount))
        }
        
        fun of(amount: BigDecimal): Money {
            return Money(amount)
        }
    }
    
    val amount: BigDecimal
    
    init {
        require(rawAmount >= BigDecimal.ZERO) { "금액은 0 이상이어야 합니다." }
        this.amount = rawAmount.setScale(0, RoundingMode.DOWN)
    }
    
    fun add(other: Money): Money {
        return Money(amount.add(other.amount))
    }
    
    fun subtract(other: Money): Money {
        return Money(amount.subtract(other.amount))
    }
    
    fun isGreaterThan(other: Money): Boolean {
        return amount.compareTo(other.amount) > 0
    }
    
    fun isGreaterThanOrEqual(other: Money): Boolean {
        return amount.compareTo(other.amount) >= 0
    }
    
    fun isLessThan(other: Money): Boolean {
        return amount.compareTo(other.amount) < 0
    }
    
    fun isLessThanOrEqual(other: Money): Boolean {
        return amount.compareTo(other.amount) <= 0
    }
    
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Money) return false
        return amount.compareTo(other.amount) == 0
    }
    
    override fun hashCode(): Int {
        return amount.hashCode()
    }
    
    fun toLong(): Long {
        return amount.longValue()
    }
    
    fun toBigDecimal(): BigDecimal {
        return amount
    }
}
```

**특징**:
- 불변 객체 (Immutable)
- 값 비교는 amount로 수행
- 금액 연산 메서드 제공

### 4.2 OrderNumber (주문번호)

```kotlin
package com.musinsa.payments.point.domain.valueobject

data class OrderNumber private constructor(val value: String) {
    companion object {
        fun of(value: String): OrderNumber {
            require(value.isNotBlank()) { "주문번호는 필수입니다." }
            return OrderNumber(value)
        }
    }
}
```

**특징**:
- 불변 객체
- 주문번호 검증 로직 포함

### 4.3 PointKey (포인트 키)

```kotlin
package com.musinsa.payments.point.domain.valueobject

data class PointKey private constructor(val value: String) {
    companion object {
        fun of(value: String): PointKey {
            require(value.isNotBlank()) { "포인트 키는 필수입니다." }
            return PointKey(value)
        }
        
        fun generate(): PointKey {
            // UUID 또는 시퀀스 기반 생성
            return PointKey(
                UUID.randomUUID().toString().substring(0, 8).uppercase()
            )
        }
    }
}
```

**특징**:
- 불변 객체
- 포인트 키 생성 로직 포함

## 5. Enum 설계

### 5.1 PointAccumulationStatus

```kotlin
package com.musinsa.payments.point.domain.entity

enum class PointAccumulationStatus {
    ACCUMULATED,  // 적립됨
    CANCELLED,    // 취소됨
    EXPIRED       // 만료됨
}
```

### 5.2 PointUsageStatus

```kotlin
package com.musinsa.payments.point.domain.entity

enum class PointUsageStatus {
    USED,                  // 사용됨
    PARTIALLY_CANCELLED,   // 부분 취소됨
    FULLY_CANCELLED        // 전체 취소됨
}
```

### 5.3 CancellationType

```kotlin
package com.musinsa.payments.point.domain.entity

enum class CancellationType {
    ACCUMULATION_CANCELLATION,  // 적립 취소
    USAGE_CANCELLATION          // 사용 취소
}
```

## 6. 도메인 서비스 설계

### 6.1 PointAccumulationService

```kotlin
package com.musinsa.payments.point.domain.service

class PointAccumulationService {
    
    fun createAccumulation(
        memberId: Long,
        amount: Money,
        expirationDate: LocalDate,
        isManualGrant: Boolean,
        pointKeyGenerator: PointKeyGenerator
    ): PointAccumulation {
        
        // 검증 로직
        validateAccumulationAmount(amount)
        validateExpirationDate(expirationDate)
        
        // PointAccumulation 생성
        return PointAccumulation().apply {
            this.pointKey = pointKeyGenerator.generate().value
            this.memberId = memberId
            this.amount = amount
            this.availableAmount = amount
            this.expirationDate = expirationDate
            this.isManualGrant = isManualGrant
            this.status = PointAccumulationStatus.ACCUMULATED
        }
    }
    
    private fun validateAccumulationAmount(amount: Money) {
        // 1원 이상 검증
        if (amount.isLessThan(Money.of(1))) {
            throw InvalidAmountException("적립 금액은 1원 이상이어야 합니다.")
        }
    }
    
    private fun validateExpirationDate(expirationDate: LocalDate) {
        // 만료일 검증 로직
    }
}
```

**책임**:
- 포인트 적립 생성 로직
- 적립 관련 비즈니스 규칙 검증

### 6.2 PointUsagePriorityService

```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    
    fun selectAccumulationsForUsage(
        memberId: Long,
        usageAmount: Money,
        accumulations: List<PointAccumulation>
    ): List<PointAccumulation> {
        
        // 사용 가능한 적립 건만 필터링
        val available = accumulations
            .filter { it.hasAvailableAmount() }
            .filter { !it.isExpired() }
        
        // 우선순위 정렬: 수기 지급 > 만료일 짧은 순
        val sorted = available.sortedWith(
            compareByDescending<PointAccumulation> { it.isManualGrant() }
                .thenBy { it.expirationDate }
        )
        
        // 사용할 적립 건 선택
        return selectAccumulations(sorted, usageAmount)
    }
    
    private fun selectAccumulations(
        accumulations: List<PointAccumulation>,
        usageAmount: Money
    ): List<PointAccumulation> {
        
        val selected = mutableListOf<PointAccumulation>()
        var remaining = usageAmount
        
        for (accumulation in accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val available = accumulation.availableAmount ?: Money.ZERO
            val useAmount = if (remaining.isLessThan(available)) {
                remaining
            } else {
                available
            }
            
            selected.add(accumulation)
            remaining = remaining.subtract(useAmount)
        }
        
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw InsufficientPointException()
        }
        
        return selected
    }
}
```

**책임**:
- 포인트 사용 우선순위 결정
- 사용할 적립 건 선택

## 7. 도메인 예외 설계

### 7.1 도메인 예외 계층 구조

```kotlin
package com.musinsa.payments.point.domain.exception

// 기본 도메인 예외
open class PointDomainException(message: String) : RuntimeException(message)

// 구체적인 예외들
class InsufficientPointException : PointDomainException(
    "사용 가능한 포인트가 부족합니다."
)

class CannotCancelAccumulationException : PointDomainException(
    "이미 사용된 포인트는 적립 취소할 수 없습니다."
)

class CannotCancelUsageException : PointDomainException(
    "취소할 수 없는 사용 건입니다."
)

class InvalidAmountException(message: String) : PointDomainException(message)

class ExceededMaxBalanceException : PointDomainException(
    "개인별 최대 보유 금액을 초과했습니다."
)
```

## 8. 리포지토리 인터페이스 (포트)

### 8.1 PointAccumulationRepository

```kotlin
package com.musinsa.payments.point.domain.repository

interface PointAccumulationRepository {
    fun save(accumulation: PointAccumulation): PointAccumulation
    fun findByPointKey(pointKey: String): PointAccumulation?
    fun findByMemberId(memberId: Long): List<PointAccumulation>
    fun findAvailableByMemberId(memberId: Long): List<PointAccumulation>
    fun calculateTotalBalance(memberId: Long): Money
    fun calculateAvailableBalance(memberId: Long): Money
}
```

### 8.2 PointUsageRepository

```kotlin
package com.musinsa.payments.point.domain.repository

interface PointUsageRepository {
    fun save(usage: PointUsage): PointUsage
    fun findByPointKey(pointKey: String): PointUsage?
    fun findByMemberId(memberId: Long): List<PointUsage>
    fun findByOrderNumber(orderNumber: String): List<PointUsage>
}
```

### 8.3 PointUsageDetailRepository

```kotlin
package com.musinsa.payments.point.domain.repository

interface PointUsageDetailRepository {
    fun saveAll(details: List<PointUsageDetail>): List<PointUsageDetail>
    fun findByPointUsageId(pointUsageId: Long): List<PointUsageDetail>
    fun findByPointAccumulationId(pointAccumulationId: Long): List<PointUsageDetail>
}
```

### 8.4 PointConfigRepository

```kotlin
package com.musinsa.payments.point.domain.repository

interface PointConfigRepository {
    fun findByConfigKey(configKey: String): PointConfig?
    fun save(config: PointConfig): PointConfig
    fun findAll(): List<PointConfig>
}
```

## 9. 다음 단계

다음 단계에서는 API 설계를 통해 REST 엔드포인트와 DTO를 정의할 예정입니다.

---

**다음 문서**: [04. API 설계](./04-API-설계.md)

