# 03. 도메인 모델 설계

## 1. 개요

헥사고날 아키텍처 기반으로 도메인 모델을 설계합니다. 도메인 중심 설계(DDD) 원칙을 적용하여 비즈니스 로직이 도메인 모델에 집중되도록 합니다.

## 2. 도메인 모델 구조

### 2.1 패키지 구조

```
com.musinsa.payments.point.domain
├── entity          # 도메인 엔티티
├── valueobject     # 값 객체
├── service         # 도메인 서비스
└── exception       # 도메인 예외

참고: 리포지토리 인터페이스(포트)는 Domain 레이어가 아닌 Application 레이어의 
application.port.output.persistence 패키지에 정의됩니다.
```

## 3. 엔티티 설계

### 3.1 Member (사용자)

```kotlin
package com.musinsa.payments.point.domain.entity

class Member {
    var id: Long? = null              // 엔티티 생성 시점에는 null, 저장 후에는 항상 값 존재
    var memberNo: String              // 비즈니스 식별자, 필수
    var name: String                  // 사용자 이름, 필수
    var createdAt: LocalDateTime      // 생성일시, 필수
    var updatedAt: LocalDateTime      // 수정일시, 필수
    
    constructor(
        memberNo: String,
        name: String,
        createdAt: LocalDateTime = LocalDateTime.now(),
        updatedAt: LocalDateTime = LocalDateTime.now()
    ) {
        require(memberNo.isNotBlank()) { "사용자 번호는 필수입니다." }
        require(name.isNotBlank()) { "사용자 이름은 필수입니다." }
        this.memberNo = memberNo
        this.name = name
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
    
    // 비즈니스 메서드
    fun isSameMember(memberId: Long): Boolean {
        return this.id == memberId
    }
    
    fun isSameMemberNo(memberNo: String): Boolean {
        return this.memberNo == memberNo
    }
}
```

**책임**:
- 사용자 정보 관리
- 사용자 식별

**설계 의도**:
- `id`: JPA 엔티티 특성상 생성 시점에는 null이지만, 저장 후에는 항상 값이 존재합니다.
- `memberNo`, `name`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다.
- `createdAt`, `updatedAt`: 생성 시점에 자동 설정되므로 non-nullable로 설계했습니다.
- 생성자를 통해 필수 값 검증을 수행하여 도메인 무결성을 보장합니다.

### 3.2 PointAccumulation (포인트 적립)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointAccumulation {
    var id: Long? = null                      // 엔티티 생성 시점에는 null, 저장 후에는 항상 값 존재
    var pointKey: String                      // 비즈니스 식별자, 필수
    var memberId: Long                        // 사용자 ID, 필수
    var amount: Money                         // 적립 금액, 필수
    var availableAmount: Money                // 사용 가능 잔액, 필수
    var expirationDate: LocalDate             // 만료일, 필수
    var isManualGrant: Boolean = false        // 수기 지급 여부, 기본값 false
    var status: PointAccumulationStatus       // 상태, 필수
    var createdAt: LocalDateTime              // 생성일시, 필수
    var updatedAt: LocalDateTime              // 수정일시, 필수
    
    constructor(
        pointKey: String,
        memberId: Long,
        amount: Money,
        expirationDate: LocalDate,
        isManualGrant: Boolean = false,
        status: PointAccumulationStatus = PointAccumulationStatus.ACCUMULATED,
        createdAt: LocalDateTime = LocalDateTime.now(),
        updatedAt: LocalDateTime = LocalDateTime.now()
    ) {
        require(pointKey.isNotBlank()) { "포인트 키는 필수입니다." }
        require(memberId > 0) { "사용자 ID는 0보다 커야 합니다." }
        require(amount.isGreaterThan(Money.ZERO)) { "적립 금액은 0보다 커야 합니다." }
        require(expirationDate.isAfter(LocalDate.now()) || expirationDate.isEqual(LocalDate.now())) {
            "만료일은 오늘 이후여야 합니다."
        }
        
        this.pointKey = pointKey
        this.memberId = memberId
        this.amount = amount
        this.availableAmount = amount  // 초기값은 적립 금액과 동일
        this.expirationDate = expirationDate
        this.isManualGrant = isManualGrant
        this.status = status
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
    
    // 비즈니스 메서드
    fun canBeCancelled(): Boolean {
        return status == PointAccumulationStatus.ACCUMULATED 
            && availableAmount == amount
    }
    
    fun isExpired(): Boolean {
        return LocalDate.now().isAfter(expirationDate)
    }
    
    fun isExpiredAt(date: LocalDate): Boolean {
        return date.isAfter(expirationDate)
    }
    
    fun use(usageAmount: Money) {
        if (availableAmount.isLessThan(usageAmount)) {
            throw InsufficientPointException()
        }
        availableAmount = availableAmount.subtract(usageAmount)
        updatedAt = LocalDateTime.now()
    }
    
    fun cancel() {
        if (!canBeCancelled()) {
            throw CannotCancelAccumulationException()
        }
        status = PointAccumulationStatus.CANCELLED
        updatedAt = LocalDateTime.now()
    }
    
    fun markAsExpired() {
        status = PointAccumulationStatus.EXPIRED
        updatedAt = LocalDateTime.now()
    }
    
    fun isManualGrant(): Boolean {
        return isManualGrant
    }
    
    fun hasAvailableAmount(): Boolean {
        return availableAmount.isGreaterThan(Money.ZERO)
    }

    fun restore(restoreAmount: Money) {
        if (restoreAmount.isLessThanOrEqual(Money.ZERO)) {
            throw InvalidAmountException("복원 금액은 0보다 커야 합니다.")
        }
        val newAvailable = availableAmount.add(restoreAmount)
        if (newAvailable.isGreaterThan(amount)) {
            throw InvalidAmountException("복원 후 사용 가능 잔액이 적립 금액을 초과할 수 없습니다.")
        }
        availableAmount = newAvailable
        updatedAt = LocalDateTime.now()
    }
}
```

**책임**:
- 포인트 적립 정보 관리
- 적립 취소 가능 여부 판단
- 만료 여부 확인
- 포인트 사용 처리
- 상태 관리

**설계 의도**:
- `id`: JPA 엔티티 특성상 생성 시점에는 null이지만, 저장 후에는 항상 값이 존재합니다.
- `pointKey`, `memberId`, `amount`, `availableAmount`, `expirationDate`, `status`, `createdAt`, `updatedAt`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다.
- `availableAmount`: 초기값은 `amount`와 동일하며, 포인트 사용 시 감소합니다.
- `isManualGrant`: 기본값은 false이며, 수기 지급인 경우에만 true로 설정됩니다.
- 생성자를 통해 필수 값 검증을 수행하여 도메인 무결성을 보장합니다.
- 비즈니스 메서드에서 nullable 체크가 불필요해져 타입 안정성이 향상되었습니다.

### 3.3 PointUsage (포인트 사용)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointUsage {
    var id: Long? = null              // 엔티티 생성 시점에는 null, 저장 후에는 항상 값 존재
    var pointKey: String              // 비즈니스 식별자, 필수
    var memberId: Long                // 사용자 ID, 필수
    var orderNumber: OrderNumber      // 주문번호, 필수
    var totalAmount: Money            // 총 사용 금액, 필수
    var cancelledAmount: Money        // 취소된 금액, 필수 (기본값 Money.ZERO)
    var status: PointUsageStatus      // 상태, 필수
    var createdAt: LocalDateTime      // 생성일시, 필수
    var updatedAt: LocalDateTime      // 수정일시, 필수
    
    constructor(
        pointKey: String,
        memberId: Long,
        orderNumber: OrderNumber,
        totalAmount: Money,
        cancelledAmount: Money = Money.ZERO,
        status: PointUsageStatus = PointUsageStatus.USED,
        createdAt: LocalDateTime = LocalDateTime.now(),
        updatedAt: LocalDateTime = LocalDateTime.now()
    ) {
        require(pointKey.isNotBlank()) { "포인트 키는 필수입니다." }
        require(memberId > 0) { "사용자 ID는 0보다 커야 합니다." }
        require(totalAmount.isGreaterThan(Money.ZERO)) { "총 사용 금액은 0보다 커야 합니다." }
        require(cancelledAmount.isGreaterThanOrEqual(Money.ZERO)) { "취소 금액은 0 이상이어야 합니다." }
        require(cancelledAmount.isLessThanOrEqual(totalAmount)) { "취소 금액은 총 사용 금액을 초과할 수 없습니다." }
        
        this.pointKey = pointKey
        this.memberId = memberId
        this.orderNumber = orderNumber
        this.totalAmount = totalAmount
        this.cancelledAmount = cancelledAmount
        this.status = status
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
    
    // 비즈니스 메서드
    fun getRemainingAmount(): Money {
        return totalAmount.subtract(cancelledAmount)
    }
    
    fun canCancel(cancelAmount: Money): Boolean {
        return getRemainingAmount().isGreaterThanOrEqual(cancelAmount)
    }
    
    fun cancel(cancelAmount: Money) {
        if (!canCancel(cancelAmount)) {
            throw CannotCancelUsageException()
        }
        cancelledAmount = cancelledAmount.add(cancelAmount)
        updateStatus()
        updatedAt = LocalDateTime.now()
    }
    
    private fun updateStatus() {
        when {
            cancelledAmount == totalAmount -> {
                status = PointUsageStatus.FULLY_CANCELLED
            }
            cancelledAmount.isGreaterThan(Money.ZERO) -> {
                status = PointUsageStatus.PARTIALLY_CANCELLED
            }
        }
    }
}
```

**책임**:
- 포인트 사용 정보 관리
- 사용 취소 처리
- 상태 관리

**설계 의도**:
- `id`: JPA 엔티티 특성상 생성 시점에는 null이지만, 저장 후에는 항상 값이 존재합니다.
- `pointKey`, `memberId`, `orderNumber`, `totalAmount`, `cancelledAmount`, `status`, `createdAt`, `updatedAt`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다.
- `cancelledAmount`: 기본값은 `Money.ZERO`이며, 취소 시 증가합니다.
- `totalAmount`: 취소 금액이 총 사용 금액을 초과할 수 없도록 생성자에서 검증합니다.
- 생성자를 통해 필수 값 검증을 수행하여 도메인 무결성을 보장합니다.
- 비즈니스 메서드에서 nullable 체크가 불필요해져 타입 안정성이 향상되었습니다.
- `getRemainingAmount()`는 이제 non-nullable `Money`를 반환하여 사용처에서 안전하게 사용할 수 있습니다.

### 3.4 PointUsageDetail (포인트 사용 상세)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointUsageDetail {
    var id: Long? = null              // 엔티티 생성 시점에는 null, 저장 후에는 항상 값 존재
    var pointUsageId: Long            // 포인트 사용 ID, 필수
    var pointAccumulationId: Long     // 포인트 적립 ID, 필수
    var amount: Money                 // 사용 금액 (1원 단위), 필수
    var cancelledAmount: Money        // 취소된 금액, 필수 (기본값 Money.ZERO)
    var createdAt: LocalDateTime      // 생성일시, 필수
    var updatedAt: LocalDateTime      // 수정일시, 필수
    
    constructor(
        pointUsageId: Long,
        pointAccumulationId: Long,
        amount: Money,
        cancelledAmount: Money = Money.ZERO,
        createdAt: LocalDateTime = LocalDateTime.now(),
        updatedAt: LocalDateTime = LocalDateTime.now()
    ) {
        require(pointUsageId > 0) { "포인트 사용 ID는 0보다 커야 합니다." }
        require(pointAccumulationId > 0) { "포인트 적립 ID는 0보다 커야 합니다." }
        require(amount.isGreaterThan(Money.ZERO)) { "사용 금액은 0보다 커야 합니다." }
        require(cancelledAmount.isGreaterThanOrEqual(Money.ZERO)) { "취소 금액은 0 이상이어야 합니다." }
        require(cancelledAmount.isLessThanOrEqual(amount)) { "취소 금액은 사용 금액을 초과할 수 없습니다." }
        
        this.pointUsageId = pointUsageId
        this.pointAccumulationId = pointAccumulationId
        this.amount = amount
        this.cancelledAmount = cancelledAmount
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
    
    // 비즈니스 메서드
    fun getRemainingAmount(): Money {
        return amount.subtract(cancelledAmount)
    }
    
    fun cancel(cancelAmount: Money) {
        if (getRemainingAmount().isLessThan(cancelAmount)) {
            throw CannotCancelDetailException()
        }
        cancelledAmount = cancelledAmount.add(cancelAmount)
        updatedAt = LocalDateTime.now()
    }
    
    fun isFullyCancelled(): Boolean {
        return cancelledAmount == amount
    }
}
```

**책임**:
- 1원 단위 포인트 사용 추적
- 사용 상세 취소 처리

**설계 의도**:
- `id`: JPA 엔티티 특성상 생성 시점에는 null이지만, 저장 후에는 항상 값이 존재합니다.
- `pointUsageId`, `pointAccumulationId`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다. 저장된 엔티티의 ID를 참조하므로 항상 값이 존재합니다.
- `amount`, `cancelledAmount`, `createdAt`, `updatedAt`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다.
- `cancelledAmount`: 기본값은 `Money.ZERO`이며, 취소 시 증가합니다.
- `amount`: 취소 금액이 사용 금액을 초과할 수 없도록 생성자에서 검증합니다.
- 생성자를 통해 필수 값 검증을 수행하여 도메인 무결성을 보장합니다.
- 비즈니스 메서드에서 nullable 체크가 불필요해져 타입 안정성이 향상되었습니다.
- `getRemainingAmount()`는 이제 non-nullable `Money`를 반환하여 사용처에서 안전하게 사용할 수 있습니다.

### 3.5 PointConfig (포인트 설정)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointConfig {
    var id: Long? = null              // 엔티티 생성 시점에는 null, 저장 후에는 항상 값 존재
    var configKey: String             // 설정 키, 필수 (UNIQUE)
    var configValue: String           // 설정 값, 필수
    var description: String? = null   // 설명, 선택적
    var createdAt: LocalDateTime      // 생성일시, 필수
    var updatedAt: LocalDateTime      // 수정일시, 필수
    
    constructor(
        configKey: String,
        configValue: String,
        description: String? = null,
        createdAt: LocalDateTime = LocalDateTime.now(),
        updatedAt: LocalDateTime = LocalDateTime.now()
    ) {
        require(configKey.isNotBlank()) { "설정 키는 필수입니다." }
        require(configValue.isNotBlank()) { "설정 값은 필수입니다." }
        
        this.configKey = configKey
        this.configValue = configValue
        this.description = description
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
    
    // 비즈니스 메서드
    fun getLongValue(): Long {
        return configValue.toLongOrNull() 
            ?: throw IllegalArgumentException("configValue가 숫자가 아닙니다: $configValue")
    }
    
    fun getIntValue(): Int {
        return configValue.toIntOrNull() 
            ?: throw IllegalArgumentException("configValue가 숫자가 아닙니다: $configValue")
    }
    
    fun getBooleanValue(): Boolean {
        return configValue.toBoolean()
    }
    
    fun updateConfigValue(newValue: String) {
        require(newValue.isNotBlank()) { "설정 값은 필수입니다." }
        this.configValue = newValue
        this.updatedAt = LocalDateTime.now()
    }
}
```

**책임**:
- 동적 설정 값 관리
- 설정 값 타입 변환
- 설정 값 업데이트

**설계 의도**:
- `id`: JPA 엔티티 특성상 생성 시점에는 null이지만, 저장 후에는 항상 값이 존재합니다.
- `configKey`, `configValue`, `createdAt`, `updatedAt`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다.
- `description`: ERD 설계에서 nullable로 정의되어 있어 선택적 필드로 유지했습니다.
- `configKey`: UNIQUE 제약조건이 있으므로 비즈니스 식별자로 사용됩니다.
- 생성자를 통해 필수 값 검증을 수행하여 도메인 무결성을 보장합니다.
- 비즈니스 메서드에서 nullable 체크가 불필요해져 타입 안정성이 향상되었습니다.
- `updateConfigValue()` 메서드를 추가하여 설정 값 변경 시 `updatedAt`을 자동 갱신합니다.

### 3.6 PointCancellation (포인트 취소)

```kotlin
package com.musinsa.payments.point.domain.entity

class PointCancellation {
    var id: Long? = null                   // 엔티티 생성 시점에는 null, 저장 후에는 항상 값 존재
    var pointKey: String                   // 취소 건 식별자, 필수 (UNIQUE)
    var cancellationType: CancellationType // 취소 유형, 필수
    var targetPointKey: String             // 대상 포인트 키 (적립/사용 키), 필수
    var memberId: Long                     // 사용자 ID, 필수
    var amount: Money                      // 취소 금액, 필수
    var reason: String? = null             // 취소 사유, 선택적
    var createdAt: LocalDateTime           // 생성일시, 필수
    
    constructor(
        pointKey: String,
        cancellationType: CancellationType,
        targetPointKey: String,
        memberId: Long,
        amount: Money,
        reason: String? = null,
        createdAt: LocalDateTime = LocalDateTime.now()
    ) {
        require(pointKey.isNotBlank()) { "포인트 키는 필수입니다." }
        require(targetPointKey.isNotBlank()) { "대상 포인트 키는 필수입니다." }
        require(memberId > 0) { "사용자 ID는 0보다 커야 합니다." }
        require(amount.isGreaterThan(Money.ZERO)) { "취소 금액은 0보다 커야 합니다." }
        
        this.pointKey = pointKey
        this.cancellationType = cancellationType
        this.targetPointKey = targetPointKey
        this.memberId = memberId
        this.amount = amount
        this.reason = reason
        this.createdAt = createdAt
    }
}
```

**책임**:
- 취소 정보 기록
- 취소 이력 관리

**설계 의도**:
- `id`: JPA 엔티티 특성상 생성 시점에는 null이지만, 저장 후에는 항상 값이 존재합니다.
- `pointKey`, `cancellationType`, `targetPointKey`, `memberId`, `amount`, `createdAt`: ERD 설계에 따라 NOT NULL 제약조건을 반영하여 non-nullable로 설계했습니다.
- `reason`: ERD 설계에서 nullable로 정의되어 있어 선택적 필드로 유지했습니다.
- `pointKey`: UNIQUE 제약조건이 있으므로 취소 건의 비즈니스 식별자로 사용됩니다.
- `targetPointKey`: 취소 대상이 되는 적립/사용 건의 pointKey를 참조합니다.
- `cancellationType`: 적립 취소(ACCUMULATION_CANCELLATION)와 사용 취소(USAGE_CANCELLATION)를 구분합니다.
- 생성자를 통해 필수 값 검증을 수행하여 도메인 무결성을 보장합니다.
- 이력 테이블 특성상 생성 후 변경되지 않으므로 `updatedAt` 필드는 포함하지 않았습니다.

## 4. 값 객체 (Value Object) 설계

### 4.1 Money (금액)

```kotlin
package com.musinsa.payments.point.domain.valueobject

class Money private constructor(rawAmount: BigDecimal) {
    companion object {
        val ZERO = Money(BigDecimal.ZERO)
        
        fun of(amount: Long): Money {
            return Money(BigDecimal.valueOf(amount))
        }
        
        fun of(amount: BigDecimal): Money {
            return Money(amount)
        }
    }
    
    val amount: BigDecimal
    
    init {
        require(rawAmount >= BigDecimal.ZERO) { "금액은 0 이상이어야 합니다." }
        this.amount = rawAmount.setScale(0, RoundingMode.DOWN)
    }
    
    fun add(other: Money): Money {
        return Money(amount.add(other.amount))
    }
    
    fun subtract(other: Money): Money {
        return Money(amount.subtract(other.amount))
    }
    
    fun isGreaterThan(other: Money): Boolean {
        return amount.compareTo(other.amount) > 0
    }
    
    fun isGreaterThanOrEqual(other: Money): Boolean {
        return amount.compareTo(other.amount) >= 0
    }
    
    fun isLessThan(other: Money): Boolean {
        return amount.compareTo(other.amount) < 0
    }
    
    fun isLessThanOrEqual(other: Money): Boolean {
        return amount.compareTo(other.amount) <= 0
    }
    
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Money) return false
        return amount.compareTo(other.amount) == 0
    }
    
    override fun hashCode(): Int {
        return amount.hashCode()
    }
    
    fun toLong(): Long {
        return amount.longValue()
    }
    
    fun toBigDecimal(): BigDecimal {
        return amount
    }
}
```

**특징**:
- 불변 객체 (Immutable)
- 값 비교는 amount로 수행
- 금액 연산 메서드 제공

### 4.2 OrderNumber (주문번호)

```kotlin
package com.musinsa.payments.point.domain.valueobject

data class OrderNumber private constructor(val value: String) {
    companion object {
        fun of(value: String): OrderNumber {
            require(value.isNotBlank()) { "주문번호는 필수입니다." }
            return OrderNumber(value)
        }
    }
}
```

**특징**:
- 불변 객체
- 주문번호 검증 로직 포함

### 4.3 PointKey (포인트 키)

```kotlin
package com.musinsa.payments.point.domain.valueobject

data class PointKey private constructor(val value: String) {
    companion object {
        fun of(value: String): PointKey {
            require(value.isNotBlank()) { "포인트 키는 필수입니다." }
            return PointKey(value)
        }
        
        fun generate(): PointKey {
            // UUID 또는 시퀀스 기반 생성
            return PointKey(
                UUID.randomUUID().toString().substring(0, 8).uppercase()
            )
        }
    }
}
```

**특징**:
- 불변 객체
- 포인트 키 생성 로직 포함

## 5. Enum 설계

### 5.1 PointAccumulationStatus

```kotlin
package com.musinsa.payments.point.domain.entity

enum class PointAccumulationStatus {
    ACCUMULATED,  // 적립됨
    CANCELLED,    // 취소됨
    EXPIRED       // 만료됨
}
```

### 5.2 PointUsageStatus

```kotlin
package com.musinsa.payments.point.domain.entity

enum class PointUsageStatus {
    USED,                  // 사용됨
    PARTIALLY_CANCELLED,   // 부분 취소됨
    FULLY_CANCELLED        // 전체 취소됨
}
```

### 5.3 CancellationType

```kotlin
package com.musinsa.payments.point.domain.entity

enum class CancellationType {
    ACCUMULATION_CANCELLATION,  // 적립 취소
    USAGE_CANCELLATION          // 사용 취소
}
```

## 6. 도메인 서비스 설계

### 6.1 PointAccumulationService

```kotlin
package com.musinsa.payments.point.domain.service

class PointAccumulationService {
    
    fun createAccumulation(
        memberId: Long,
        amount: Money,
        expirationDate: LocalDate,
        isManualGrant: Boolean,
        pointKeyGenerator: PointKeyGenerator
    ): PointAccumulation {
        
        // 검증 로직
        validateAccumulationAmount(amount)
        validateExpirationDate(expirationDate)
        
        // PointAccumulation 생성 (생성자에서 필수 값 검증 수행)
        return PointAccumulation(
            pointKey = pointKeyGenerator.generate().value,
            memberId = memberId,
            amount = amount,
            expirationDate = expirationDate,
            isManualGrant = isManualGrant,
            status = PointAccumulationStatus.ACCUMULATED
        )
    }
    
    private fun validateAccumulationAmount(amount: Money) {
        // 1원 이상 검증
        if (amount.isLessThan(Money.of(1))) {
            throw InvalidAmountException("적립 금액은 1원 이상이어야 합니다.")
        }
    }
    
    private fun validateExpirationDate(expirationDate: LocalDate) {
        // 만료일 검증 로직
    }
}
```

**책임**:
- 포인트 적립 생성 로직
- 적립 관련 비즈니스 규칙 검증

### 6.2 PointUsagePriorityService

```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    
    fun selectAccumulationsForUsage(
        memberId: Long,
        usageAmount: Money,
        accumulations: List<PointAccumulation>
    ): List<PointAccumulation> {
        
        // 사용 가능한 적립 건만 필터링
        val available = accumulations
            .filter { it.hasAvailableAmount() }
            .filter { !it.isExpired() }
        
        // 우선순위 정렬: 수기 지급 > 만료일 짧은 순
        val sorted = available.sortedWith(
            compareByDescending<PointAccumulation> { it.isManualGrant() }
                .thenBy { it.expirationDate }
        )
        
        // 사용할 적립 건 선택
        return selectAccumulations(sorted, usageAmount)
    }
    
    private fun selectAccumulations(
        accumulations: List<PointAccumulation>,
        usageAmount: Money
    ): List<PointAccumulation> {
        
        val selected = mutableListOf<PointAccumulation>()
        var remaining = usageAmount
        
        for (accumulation in accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val available = accumulation.availableAmount
            val useAmount = if (remaining.isLessThan(available)) {
                remaining
            } else {
                available
            }
            
            selected.add(accumulation)
            remaining = remaining.subtract(useAmount)
        }
        
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw InsufficientPointException()
        }
        
        return selected
    }
}
```

**책임**:
- 포인트 사용 우선순위 결정
- 사용할 적립 건 선택

## 7. 도메인 예외 설계

### 7.1 도메인 예외 계층 구조

```kotlin
package com.musinsa.payments.point.domain.exception

// 기본 도메인 예외
open class PointDomainException(message: String) : RuntimeException(message)

// 구체적인 예외들
class InsufficientPointException : PointDomainException(
    "사용 가능한 포인트가 부족합니다."
)

class CannotCancelAccumulationException : PointDomainException(
    "이미 사용된 포인트는 적립 취소할 수 없습니다."
)

class CannotCancelUsageException : PointDomainException(
    "취소할 수 없는 사용 건입니다."
)

class InvalidAmountException(message: String) : PointDomainException(message)

class ExceededMaxBalanceException : PointDomainException(
    "개인별 최대 보유 금액을 초과했습니다."
)

class ConfigNotFoundException : PointDomainException(
    "설정 정보를 찾을 수 없습니다."
)

class ExceededMaxAccumulationException(message: String) : PointDomainException(message)

class InvalidExpirationDateException(message: String) : PointDomainException(message)

class AccumulationNotFoundException : PointDomainException(
    "적립 건을 찾을 수 없습니다."
)

class UsageNotFoundException : PointDomainException(
    "사용 건을 찾을 수 없습니다."
)

class CannotCancelDetailException : PointDomainException(
    "상세 내역을 취소할 수 없습니다."
)
```

## 8. 포트 인터페이스 (아웃바운드 포트)

> **참고**: 헥사고날 아키텍처 원칙에 따라, 리포지토리 인터페이스는 Domain 레이어가 아닌 Application 레이어의 `application.port.output.persistence` 패키지에 정의됩니다. 이는 도메인이 인프라스트럭처에 의존하지 않도록 하기 위함입니다.

### 8.1 PointAccumulationPersistencePort

```kotlin
package com.musinsa.payments.point.application.port.output.persistence

interface PointAccumulationPersistencePort {
    fun save(accumulation: PointAccumulation): PointAccumulation
    fun findByPointKey(pointKey: String): Optional<PointAccumulation>
    fun findByMemberIdAndStatus(memberId: Long, status: PointAccumulationStatus): List<PointAccumulation>
    fun findAvailableAccumulationsByMemberId(memberId: Long): List<PointAccumulation>
    fun sumAvailableAmountByMemberId(memberId: Long): Money
}
```

### 8.2 PointUsagePersistencePort

```kotlin
package com.musinsa.payments.point.application.port.output.persistence

interface PointUsagePersistencePort {
    fun save(usage: PointUsage): PointUsage
    fun findByPointKey(pointKey: String): Optional<PointUsage>
    fun findByMemberIdAndOrderNumber(memberId: Long, orderNumber: OrderNumber): List<PointUsage>
    fun findUsageHistoryByMemberId(
        memberId: Long,
        orderNumber: String?,
        pageable: Pageable
    ): Page<PointUsage>
}
```

### 8.3 PointUsageDetailPersistencePort

```kotlin
package com.musinsa.payments.point.application.port.output.persistence

interface PointUsageDetailPersistencePort {
    fun saveAll(details: List<PointUsageDetail>): List<PointUsageDetail>
    fun findByUsagePointKey(pointKey: String): List<PointUsageDetail>
    fun findByAccumulationPointKey(pointKey: String): List<PointUsageDetail>
}
```

### 8.4 PointConfigPort

```kotlin
package com.musinsa.payments.point.application.port.output.config

interface PointConfigPort {
    fun findByConfigKey(configKey: String): Optional<PointConfig>
    fun save(config: PointConfig): PointConfig
    fun findAll(): List<PointConfig>
}
```

## 9. 다음 단계

다음 단계에서는 API 설계를 통해 REST 엔드포인트와 DTO를 정의할 예정입니다.

---

**다음 문서**: [04. API 설계](./04-API-설계.md)

