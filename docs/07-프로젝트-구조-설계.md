# 07. 프로젝트 구조 설계 (헥사고날 아키텍처)

## 1. 개요

헥사고날 아키텍처(Hexagonal Architecture)를 적용하여 포인트 시스템의 프로젝트 구조를 설계합니다. 도메인 중심 설계로 비즈니스 로직과 인프라스트럭처를 분리합니다.

## 2. 헥사고날 아키텍처 개요

### 2.1 아키텍처 특징

- **도메인 중심**: 비즈니스 로직이 도메인 레이어에 집중
- **의존성 역전**: 도메인이 인프라스트럭처에 의존하지 않음
- **포트와 어댑터**: 포트(인터페이스)와 어댑터(구현)로 분리

### 2.2 레이어 구조

```
┌─────────────────────────────────────┐
│   Presentation (프레젠테이션)      │
│  (Web Controller, CLI, etc.)        │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   Application (애플리케이션)        │
│  (Use Case, Port Interface)         │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│         Domain (도메인)              │
│  (Entity, Value Object, Service)     │
└─────────────────────────────────────┘
              ↑
┌─────────────────────────────────────┐
│  Infrastructure (인프라스트럭처)   │
│  (Persistence, Config, External)     │
└─────────────────────────────────────┘
```

### 2.3 레이어별 역할

- **Domain 레이어**: 핵심 비즈니스 로직을 담당하는 순수한 도메인 모델
  - 엔티티, 값 객체, 도메인 서비스, 도메인 예외
  - 다른 레이어에 의존하지 않는 독립적인 레이어
  - 리포지토리 인터페이스는 포함하지 않음 (포트는 Application 레이어에서 정의)

- **Application 레이어**: 비즈니스 유스케이스를 조합하고 조율하는 레이어
  - 포트 인터페이스 정의 (인바운드/아웃바운드)
    - 인바운드 포트: Use Case 인터페이스
    - 아웃바운드 포트: 영속성, 설정 등 외부 시스템과의 인터페이스
  - 애플리케이션 서비스가 Use Case를 구현

- **Infrastructure 레이어**: 외부 시스템과의 통신을 담당하는 레이어
  - Application 레이어의 아웃바운드 포트 인터페이스를 구현
  - 영속성 구현 (JPA, 데이터베이스)
  - 설정 관리
  - 외부 API 연동

- **Presentation 레이어**: 사용자 인터페이스를 담당하는 레이어
  - Application 레이어의 인바운드 포트를 호출
  - REST API 컨트롤러
  - DTO 변환
  - HTTP 요청/응답 처리

## 3. 프로젝트 구조

### 3.1 전체 패키지 구조

```
com.musinsa.payments.point
├── domain                          # 도메인 레이어 (핵심 비즈니스 로직)
│   ├── entity                      # 도메인 엔티티
│   │   ├── Member.kt
│   │   ├── PointAccumulation.kt
│   │   ├── PointUsage.kt
│   │   ├── PointUsageDetail.kt
│   │   ├── PointConfig.kt
│   │   ├── PointCancellation.kt
│   │   └── enums
│   │       ├── PointAccumulationStatus.kt
│   │       ├── PointUsageStatus.kt
│   │       └── CancellationType.kt
│   ├── valueobject                 # 값 객체
│   │   ├── Money.kt
│   │   ├── OrderNumber.kt
│   │   └── PointKey.kt
│   ├── service                     # 도메인 서비스
│   │   ├── PointAccumulationDomainService.kt
│   │   └── PointUsagePriorityService.kt
│   └── exception                   # 도메인 예외
│       ├── PointDomainException.kt
│       ├── InsufficientPointException.kt
│       ├── CannotCancelAccumulationException.kt
│       └── ...
├── application                     # 애플리케이션 레이어 (유스케이스)
│   ├── port                        # 포트 인터페이스
│   │   ├── input                   # 인바운드 포트
│   │   │   ├── PointAccumulationUseCase.kt
│   │   │   ├── PointUsageUseCase.kt
│   │   │   ├── PointCancellationUseCase.kt
│   │   │   └── PointQueryUseCase.kt
│   │   └── output                  # 아웃바운드 포트
│   │       ├── persistence         # 영속성 포트
│   │       │   ├── PointAccumulationPersistencePort.kt
│   │       │   ├── PointUsagePersistencePort.kt
│   │       │   └── ...
│   │       └── config              # 설정 포트
│   │           └── PointConfigPort.kt
│   └── service                     # 애플리케이션 서비스 (Use Case 구현)
│       ├── PointAccumulationService.kt
│       ├── PointUsageService.kt
│       ├── PointCancellationService.kt
│       └── PointQueryService.kt
├── infrastructure                  # 인프라스트럭처 레이어 (외부 시스템 통신)
│   ├── persistence                 # 영속성 구현
│   │   ├── jpa                     # JPA 구현
│   │   │   ├── entity              # JPA 엔티티
│   │   │   │   ├── MemberEntity.kt
│   │   │   │   ├── PointAccumulationEntity.kt
│   │   │   │   └── ...
│   │   │   ├── repository          # JPA 리포지토리
│   │   │   │   ├── JpaPointAccumulationRepository.kt
│   │   │   │   └── ...
│   │   │   └── mapper              # 엔티티 매퍼
│   │   │       └── PointEntityMapper.kt
│   │   └── adapter                 # 영속성 어댑터
│   │       ├── PointAccumulationPersistenceAdapter.kt
│   │       ├── PointUsagePersistenceAdapter.kt
│   │       └── ...
│   ├── config                      # 설정 어댑터
│   │   └── PointConfigAdapter.kt
│   └── external                    # 외부 API 어댑터 (필요시)
│       └── ...
└── presentation                    # 프레젠테이션 레이어 (사용자 인터페이스)
    ├── web                         # 웹 어댑터
    │   ├── controller              # REST 컨트롤러
    │   │   ├── PointAccumulationController.kt
    │   │   ├── PointUsageController.kt
    │   │   ├── PointCancellationController.kt
    │   │   └── PointQueryController.kt
    │   ├── dto                     # 요청/응답 DTO
    │   │   ├── request
    │   │   │   ├── AccumulatePointRequest.kt
    │   │   │   ├── UsePointRequest.kt
    │   │   │   └── ...
    │   │   └── response
    │   │       ├── AccumulatePointResponse.kt
    │   │       ├── UsePointResponse.kt
    │   │       └── ...
    │   └── mapper                  # DTO 매퍼
    │       └── PointDtoMapper.kt
    └── cli                         # CLI 어댑터 (필요시)
        └── ...
```

## 4. 레이어별 상세 설계

### 4.1 Domain 레이어 (도메인)

#### 4.1.1 entity 패키지
도메인 엔티티와 Enum을 포함합니다.

**특징**:
- 비즈니스 로직 포함
- JPA 어노테이션 없음 (순수 도메인 모델)
- 도메인 규칙 검증 메서드 포함

**예시**:
```kotlin
package com.musinsa.payments.point.domain.entity

class PointAccumulation {
    var id: Long? = null                      // 저장 전에는 null, 저장 후에는 항상 값 존재
    var pointKey: String                      // 비즈니스 식별자, 필수
    var memberId: Long                        // 사용자 ID, 필수
    var amount: Money                         // 적립 금액, 필수
    var availableAmount: Money                // 사용 가능 잔액, 필수
    var expirationDate: LocalDate             // 만료일, 필수
    var isManualGrant: Boolean = false        // 수기 지급 여부
    var status: PointAccumulationStatus       // 상태, 필수

    // 비즈니스 메서드
    fun canBeCancelled(): Boolean { ... }
    fun use(usageAmount: Money) { ... }
    fun restore(restoreAmount: Money) { ... }
}
```

#### 4.1.2 valueobject 패키지
값 객체를 포함합니다.

**특징**:
- 불변 객체 (Immutable)
- 값 비교 로직 포함
- 도메인 검증 로직 포함

**예시**:
```kotlin
package com.musinsa.payments.point.domain.valueobject

class Money(private val amount: BigDecimal) {
    fun add(other: Money): Money { ... }
    fun subtract(other: Money): Money { ... }
}
```

#### 4.1.3 service 패키지
도메인 서비스를 포함합니다.

**특징**:
- 도메인 로직만 포함
- 트랜잭션 관리 없음
- 순수 비즈니스 로직

**예시**:
```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    fun selectAccumulationsForUsage(...): List<PointAccumulation> {
        // 우선순위 로직
    }
}
```

### 4.2 Application 레이어 (애플리케이션)

#### 4.2.1 application.port.input 패키지
인바운드 포트(Use Case 인터페이스)를 포함합니다.

**특징**:
- 애플리케이션 서비스가 구현
- 도메인 모델 사용
- 외부 인터페이스와 독립적

**예시**:
```kotlin
package com.musinsa.payments.point.application.port.input

interface PointAccumulationUseCase {
    fun accumulate(request: AccumulatePointRequest): AccumulatePointResponse
    fun cancelAccumulation(
        pointKey: String, 
        request: CancelAccumulationRequest
    ): CancelAccumulationResponse
}
```

#### 4.2.2 application.port.output 패키지
아웃바운드 포트를 포함합니다.

**특징**:
- 영속성, 외부 API 등과의 인터페이스
- 도메인 모델 사용
- 구현은 인프라스트럭처 레이어에서 제공

**예시**:
```kotlin
package com.musinsa.payments.point.application.port.output.persistence

interface PointAccumulationPersistencePort {
    fun save(accumulation: PointAccumulation): PointAccumulation
    fun findByPointKey(pointKey: String): PointAccumulation?
}
```

#### 4.2.3 application.service 패키지
애플리케이션 서비스를 포함합니다.

**특징**:
- Use Case 인터페이스 구현
- 트랜잭션 관리
- 도메인 서비스 조합
- 포트 호출

**예시**:
```kotlin
package com.musinsa.payments.point.application.service

@Service
@Transactional
class PointAccumulationService(
    private val persistencePort: PointAccumulationPersistencePort,
    private val configPort: PointConfigPort,
    private val domainService: PointAccumulationDomainService
) : PointAccumulationUseCase {
    
    override fun accumulate(request: AccumulatePointRequest): AccumulatePointResponse {
        // 1. 설정 조회
        // 2. 검증
        // 3. 도메인 서비스 호출
        // 4. 저장
        // 5. 응답 생성
    }
}
```

### 4.3 Infrastructure 레이어 (인프라스트럭처)

#### 4.3.1 infrastructure.persistence 패키지
영속성 구현을 포함합니다.

**특징**:
- JPA 엔티티와 도메인 엔티티 변환
- 포트 인터페이스 구현
- 데이터베이스 접근 로직

**예시**:
```kotlin
package com.musinsa.payments.point.infrastructure.persistence.adapter

@Component
class PointAccumulationPersistenceAdapter(
    private val jpaRepository: JpaPointAccumulationRepository,
    private val mapper: PointEntityMapper
) : PointAccumulationPersistencePort {
    
    override fun save(accumulation: PointAccumulation): PointAccumulation {
        val entity = mapper.toEntity(accumulation)
        val saved = jpaRepository.save(entity)
        return mapper.toDomain(saved)
    }
}
```

#### 4.3.2 infrastructure.config 패키지
설정 어댑터를 포함합니다.

**특징**:
- 설정 포트 인터페이스 구현
- 설정 값 조회 및 관리

**예시**:
```kotlin
package com.musinsa.payments.point.infrastructure.config

@Component
class PointConfigAdapter(
    private val configRepository: PointConfigRepository
) : PointConfigPort {
    
    override fun getMaxAccumulationAmount(): Money {
        // 설정 조회 로직
    }
}
```

### 4.4 Presentation 레이어 (프레젠테이션)

#### 4.4.1 presentation.web 패키지
웹 어댑터를 포함합니다.

**특징**:
- REST API 컨트롤러
- HTTP 요청/응답 처리
- DTO 변환
- Use Case 호출

**예시**:
```kotlin
package com.musinsa.payments.point.presentation.web.controller

@RestController
@RequestMapping("/api/points")
class PointAccumulationController(
    private val useCase: PointAccumulationUseCase,
    private val mapper: PointDtoMapper
) {
    
    @PostMapping("/accumulate")
    fun accumulate(
        @RequestBody request: AccumulatePointRequest
    ): ResponseEntity<AccumulatePointResponse> {
        val response = useCase.accumulate(request)
        return ResponseEntity.ok(response)
    }
}
```

## 5. 의존성 방향

### 5.1 의존성 규칙

```
Presentation → Application → Domain
              ↓              ↑
              └── port.output ──┘
                              ↑
Infrastructure ───────────────┘
```

### 5.2 의존성 상세

1. **Presentation → Application.port.input**: 프레젠테이션 레이어는 애플리케이션 레이어의 인바운드 포트에 의존
2. **Application → Domain**: 애플리케이션 레이어는 도메인 모델 사용
3. **Application → Application.port.output**: 애플리케이션 레이어는 아웃바운드 포트 인터페이스에 의존
4. **Infrastructure → Application.port.output**: 인프라스트럭처 레이어는 아웃바운드 포트 인터페이스를 구현
5. **Infrastructure → Domain**: 인프라스트럭처 레이어는 도메인 모델 사용

### 5.3 의존성 금지

- **Domain → Application**: 도메인은 애플리케이션 레이어에 의존하지 않음
- **Domain → Infrastructure**: 도메인은 인프라스트럭처 레이어에 의존하지 않음
- **Domain → Presentation**: 도메인은 프레젠테이션 레이어에 의존하지 않음
- **Domain → Port**: 도메인은 포트 인터페이스에 의존하지 않음 (리포지토리 인터페이스는 Application 레이어에 정의)
- **Application → Infrastructure**: 애플리케이션 레이어는 인프라스트럭처 구현에 직접 의존하지 않음 (포트 인터페이스만 의존)
- **Presentation → Infrastructure**: 프레젠테이션 레이어는 인프라스트럭처에 직접 의존하지 않음

## 6. 모듈 구조 (옵션)

대규모 프로젝트의 경우 모듈로 분리할 수 있습니다.

```
musinsa-payments-point/
├── point-domain/              # 도메인 모듈
├── point-application/         # 애플리케이션 모듈
├── point-infrastructure/      # 인프라스트럭처 모듈
│   ├── point-infrastructure-persistence/  # 영속성 모듈
│   └── point-infrastructure-config/       # 설정 모듈
└── point-presentation/        # 프레젠테이션 모듈
    └── point-presentation-web/             # 웹 모듈
```

## 7. 빌드 설정

### 7.1 Maven/Gradle 구조

```
src/
├── main/
│   ├── kotlin/
│   │   └── com/musinsa/payments/point/
│   └── resources/
│       ├── application.yml
│       └── db/migration/  # Flyway/Liquibase
└── test/
    ├── kotlin/
    │   └── com/musinsa/payments/point/
    └── resources/
        └── application-test.yml
```

## 8. 다음 단계

다음 단계에서는 AWS 아키텍처 설계를 통해 클라우드 환경에서의 배포 구조를 설계할 예정입니다.

---

**다음 문서**: [08. AWS 아키텍처 설계](./08-AWS-아키텍처-설계.md)

