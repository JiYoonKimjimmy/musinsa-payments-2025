# 07. 프로젝트 구조 설계 (헥사고날 아키텍처)

## 1. 개요

헥사고날 아키텍처(Hexagonal Architecture)를 적용하여 포인트 시스템의 프로젝트 구조를 설계합니다. 도메인 중심 설계로 비즈니스 로직과 인프라스트럭처를 분리합니다.

## 2. 헥사고날 아키텍처 개요

### 2.1 아키텍처 특징

- **도메인 중심**: 비즈니스 로직이 도메인 레이어에 집중
- **의존성 역전**: 도메인이 인프라스트럭처에 의존하지 않음
- **포트와 어댑터**: 포트(인터페이스)와 어댑터(구현)로 분리

### 2.2 레이어 구조

```
┌─────────────────────────────────────┐
│      Adapter-In (인바운드)          │
│  (Web Controller, CLI, etc.)        │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      Port-In (인바운드 포트)        │
│  (Use Case Interface)               │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│         Domain (도메인)              │
│  (Entity, Value Object, Service)     │
└─────────────────────────────────────┘
              ↑
┌─────────────────────────────────────┐
│      Port-Out (아웃바운드 포트)     │
│  (Repository Interface, etc.)        │
└─────────────────────────────────────┘
              ↑
┌─────────────────────────────────────┐
│   Adapter-Out (아웃바운드 어댑터)   │
│  (JPA Repository, External API)       │
└─────────────────────────────────────┘
```

## 3. 프로젝트 구조

### 3.1 전체 패키지 구조

```
com.musinsa.payments.point
├── domain                          # 도메인 레이어 (핵심)
│   ├── entity                      # 도메인 엔티티
│   │   ├── Member.kt
│   │   ├── PointAccumulation.kt
│   │   ├── PointUsage.kt
│   │   ├── PointUsageDetail.kt
│   │   ├── PointConfig.kt
│   │   ├── PointCancellation.kt
│   │   └── enums
│   │       ├── PointAccumulationStatus.kt
│   │       ├── PointUsageStatus.kt
│   │       └── CancellationType.kt
│   ├── valueobject                 # 값 객체
│   │   ├── Money.kt
│   │   ├── OrderNumber.kt
│   │   └── PointKey.kt
│   ├── repository                  # 리포지토리 인터페이스 (포트)
│   │   ├── PointAccumulationRepository.kt
│   │   ├── PointUsageRepository.kt
│   │   ├── PointUsageDetailRepository.kt
│   │   ├── PointConfigRepository.kt
│   │   ├── PointCancellationRepository.kt
│   │   └── MemberRepository.kt
│   ├── service                     # 도메인 서비스
│   │   ├── PointAccumulationDomainService.kt
│   │   └── PointUsagePriorityService.kt
│   └── exception                   # 도메인 예외
│       ├── PointDomainException.kt
│       ├── InsufficientPointException.kt
│       ├── CannotCancelAccumulationException.kt
│       └── ...
├── port                            # 포트 레이어
│   ├── in                          # 인바운드 포트
│   │   ├── PointAccumulationUseCase.kt
│   │   ├── PointUsageUseCase.kt
│   │   ├── PointCancellationUseCase.kt
│   │   └── PointQueryUseCase.kt
│   └── out                         # 아웃바운드 포트
│       ├── persistence             # 영속성 포트
│       │   ├── PointAccumulationPersistencePort.kt
│       │   ├── PointUsagePersistencePort.kt
│       │   └── ...
│       └── config                  # 설정 포트
│           └── PointConfigPort.kt
├── adapter                         # 어댑터 레이어
│   ├── in                          # 인바운드 어댑터
│   │   └── web                     # 웹 어댑터
│   │       ├── controller          # REST 컨트롤러
│   │       │   ├── PointAccumulationController.kt
│   │       │   ├── PointUsageController.kt
│   │       │   ├── PointCancellationController.kt
│   │       │   └── PointQueryController.kt
│   │       ├── dto                 # 요청/응답 DTO
│   │       │   ├── request
│   │       │   │   ├── AccumulatePointRequest.kt
│   │       │   │   ├── UsePointRequest.kt
│   │       │   │   └── ...
│   │       │   └── response
│   │       │       ├── AccumulatePointResponse.kt
│   │       │       ├── UsePointResponse.kt
│   │       │       └── ...
│   │       └── mapper              # DTO 매퍼
│   │           └── PointDtoMapper.kt
│   └── out                         # 아웃바운드 어댑터
│       ├── persistence             # 영속성 어댑터
│       │   ├── jpa                 # JPA 구현
│       │   │   ├── entity          # JPA 엔티티
│       │   │   │   ├── MemberEntity.kt
│       │   │   │   ├── PointAccumulationEntity.kt
│       │   │   │   └── ...
│       │   │   ├── repository      # JPA 리포지토리
│       │   │   │   ├── JpaPointAccumulationRepository.kt
│       │   │   │   └── ...
│       │   │   └── mapper          # 엔티티 매퍼
│       │   │       └── PointEntityMapper.kt
│       │   └── PointAccumulationPersistenceAdapter.kt
│       └── config                  # 설정 어댑터
│           └── PointConfigAdapter.kt
├── service                         # 애플리케이션 서비스
│   ├── PointAccumulationService.kt
│   ├── PointUsageService.kt
│   ├── PointCancellationService.kt
│   └── PointQueryService.kt
├── config                          # 설정 클래스
│   ├── PointConfig.kt
│   ├── JpaConfig.kt
│   └── CacheConfig.kt
└── MusinsaPaymentsPointApplication.kt
```

## 4. 레이어별 상세 설계

### 4.1 Domain 레이어 (도메인)

#### 4.1.1 entity 패키지
도메인 엔티티와 Enum을 포함합니다.

**특징**:
- 비즈니스 로직 포함
- JPA 어노테이션 없음 (순수 도메인 모델)
- 도메인 규칙 검증 메서드 포함

**예시**:
```kotlin
package com.musinsa.payments.point.domain.entity

class PointAccumulation {
    var id: Long? = null
    var pointKey: String? = null
    var memberId: Long? = null
    var amount: Money? = null
    var availableAmount: Money? = null
    var expirationDate: LocalDate? = null
    var isManualGrant: Boolean = false
    var status: PointAccumulationStatus? = null
    
    // 비즈니스 메서드
    fun canBeCancelled(): Boolean { ... }
    fun use(usageAmount: Money) { ... }
}
```

#### 4.1.2 valueobject 패키지
값 객체를 포함합니다.

**특징**:
- 불변 객체 (Immutable)
- 값 비교 로직 포함
- 도메인 검증 로직 포함

**예시**:
```kotlin
package com.musinsa.payments.point.domain.valueobject

class Money(private val amount: BigDecimal) {
    fun add(other: Money): Money { ... }
    fun subtract(other: Money): Money { ... }
}
```

#### 4.1.3 repository 패키지
리포지토리 인터페이스를 포함합니다.

**특징**:
- 도메인 용어 사용
- 도메인 엔티티 반환
- 구현 세부사항 없음

**예시**:
```kotlin
package com.musinsa.payments.point.domain.repository

interface PointAccumulationRepository {
    fun save(accumulation: PointAccumulation): PointAccumulation
    fun findByPointKey(pointKey: String): PointAccumulation?
}
```

#### 4.1.4 service 패키지
도메인 서비스를 포함합니다.

**특징**:
- 도메인 로직만 포함
- 트랜잭션 관리 없음
- 순수 비즈니스 로직

**예시**:
```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    fun selectAccumulationsForUsage(...): List<PointAccumulation> {
        // 우선순위 로직
    }
}
```

### 4.2 Port 레이어 (포트)

#### 4.2.1 port.in 패키지
인바운드 포트(Use Case 인터페이스)를 포함합니다.

**특징**:
- 애플리케이션 서비스가 구현
- 도메인 모델 사용
- 외부 인터페이스와 독립적

**예시**:
```kotlin
package com.musinsa.payments.point.port.in

interface PointAccumulationUseCase {
    fun accumulate(request: AccumulatePointRequest): AccumulatePointResponse
    fun cancelAccumulation(
        pointKey: String, 
        request: CancelAccumulationRequest
    ): CancelAccumulationResponse
}
```

#### 4.2.2 port.out 패키지
아웃바운드 포트를 포함합니다.

**특징**:
- 영속성, 외부 API 등과의 인터페이스
- 도메인 모델 사용
- 구현은 어댑터에서 제공

**예시**:
```kotlin
package com.musinsa.payments.point.port.out.persistence

interface PointAccumulationPersistencePort {
    fun save(accumulation: PointAccumulation): PointAccumulation
    fun findByPointKey(pointKey: String): PointAccumulation?
}
```

### 4.3 Adapter 레이어 (어댑터)

#### 4.3.1 adapter.in.web 패키지
웹 어댑터를 포함합니다.

**특징**:
- REST API 컨트롤러
- HTTP 요청/응답 처리
- DTO 변환
- Use Case 호출

**예시**:
```kotlin
package com.musinsa.payments.point.adapter.in.web.controller

@RestController
@RequestMapping("/api/points")
class PointAccumulationController(
    private val useCase: PointAccumulationUseCase,
    private val mapper: PointDtoMapper
) {
    
    @PostMapping("/accumulate")
    fun accumulate(
        @RequestBody request: AccumulatePointRequest
    ): ResponseEntity<AccumulatePointResponse> {
        val response = useCase.accumulate(request)
        return ResponseEntity.ok(response)
    }
}
```

#### 4.3.2 adapter.out.persistence 패키지
영속성 어댑터를 포함합니다.

**특징**:
- JPA 엔티티와 도메인 엔티티 변환
- 포트 인터페이스 구현
- 데이터베이스 접근 로직

**예시**:
```kotlin
package com.musinsa.payments.point.adapter.out.persistence

@Component
class PointAccumulationPersistenceAdapter(
    private val jpaRepository: JpaPointAccumulationRepository,
    private val mapper: PointEntityMapper
) : PointAccumulationPersistencePort {
    
    override fun save(accumulation: PointAccumulation): PointAccumulation {
        val entity = mapper.toEntity(accumulation)
        val saved = jpaRepository.save(entity)
        return mapper.toDomain(saved)
    }
}
```

### 4.4 Service 레이어 (애플리케이션 서비스)

#### 4.4.1 service 패키지
애플리케이션 서비스를 포함합니다.

**특징**:
- Use Case 인터페이스 구현
- 트랜잭션 관리
- 도메인 서비스 조합
- 포트 호출

**예시**:
```kotlin
package com.musinsa.payments.point.service

@Service
@Transactional
class PointAccumulationService(
    private val persistencePort: PointAccumulationPersistencePort,
    private val configPort: PointConfigPort,
    private val domainService: PointAccumulationDomainService
) : PointAccumulationUseCase {
    
    override fun accumulate(request: AccumulatePointRequest): AccumulatePointResponse {
        // 1. 설정 조회
        // 2. 검증
        // 3. 도메인 서비스 호출
        // 4. 저장
        // 5. 응답 생성
    }
}
```

## 5. 의존성 방향

### 5.1 의존성 규칙

```
Adapter-In → Port-In → Service → Domain
                                    ↑
Adapter-Out → Port-Out ────────────┘
```

### 5.2 의존성 상세

1. **Adapter-In → Port-In**: 인바운드 어댑터는 포트 인터페이스에 의존
2. **Service → Port-In**: 서비스는 포트 인터페이스를 구현
3. **Service → Domain**: 서비스는 도메인 모델 사용
4. **Service → Port-Out**: 서비스는 아웃바운드 포트에 의존
5. **Adapter-Out → Port-Out**: 아웃바운드 어댑터는 포트 인터페이스를 구현
6. **Adapter-Out → Domain**: 아웃바운드 어댑터는 도메인 모델 사용

### 5.3 의존성 금지

- **Domain → Adapter**: 도메인은 어댑터에 의존하지 않음
- **Domain → Port**: 도메인은 포트에 의존하지 않음
- **Domain → Service**: 도메인은 서비스에 의존하지 않음

## 6. 모듈 구조 (옵션)

대규모 프로젝트의 경우 모듈로 분리할 수 있습니다.

```
musinsa-payments-point/
├── point-domain/          # 도메인 모듈
├── point-application/     # 애플리케이션 모듈
├── point-adapter-in-web/  # 웹 어댑터 모듈
├── point-adapter-out-persistence/  # 영속성 어댑터 모듈
└── point-adapter-out-config/      # 설정 어댑터 모듈
```

## 7. 빌드 설정

### 7.1 Maven/Gradle 구조

```
src/
├── main/
│   ├── kotlin/
│   │   └── com/musinsa/payments/point/
│   └── resources/
│       ├── application.yml
│       └── db/migration/  # Flyway/Liquibase
└── test/
    ├── kotlin/
    │   └── com/musinsa/payments/point/
    └── resources/
        └── application-test.yml
```

## 8. 다음 단계

다음 단계에서는 AWS 아키텍처 설계를 통해 클라우드 환경에서의 배포 구조를 설계할 예정입니다.

---

**다음 문서**: [08. AWS 아키텍처 설계](./08-AWS-아키텍처-설계.md)

