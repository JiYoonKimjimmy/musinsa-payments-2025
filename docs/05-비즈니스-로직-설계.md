# 05. 비즈니스 로직 설계

## 1. 개요

포인트 시스템의 핵심 비즈니스 로직을 설계합니다. 적립, 적립 취소, 사용, 사용 취소의 각 기능별로 서비스 레이어를 구성합니다.

## 2. 서비스 레이어 구조

### 2.1 패키지 구조

```
com.musinsa.payments.point.application.service
├── PointAccumulationService      # 적립 서비스
├── PointUsageService             # 사용 서비스
├── PointCancellationService      # 취소 서비스
└── PointQueryService             # 조회 서비스
```

## 3. 포인트 적립 서비스

### 3.1 PointAccumulationService

#### 3.1.1 적립 처리 로직

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointAccumulationUseCase
import com.musinsa.payments.point.application.port.output.PointKeyGenerator
import com.musinsa.payments.point.application.port.output.config.PointConfigPort
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort

@Transactional
@Service
class PointAccumulationService(
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointConfigPort: PointConfigPort,
    private val pointKeyGenerator: PointKeyGenerator
) : PointAccumulationUseCase {
    
    override fun accumulate(
        memberId: Long,
        amount: Long,
        expirationDays: Int?,
        isManualGrant: Boolean
    ): PointAccumulation {
        // 1. 적립 금액 검증
        val moneyAmount = Money.of(amount)
        if (moneyAmount.isLessThanOrEqual(Money.ZERO)) {
            throw InvalidAmountException("적립 금액은 0보다 커야 합니다.")
        }
        
        // 2. 최대 적립 금액 검증
        val maxAccumulationAmount = getConfigLongValue("MAX_ACCUMULATION_AMOUNT_PER_TIME")
        if (amount > maxAccumulationAmount) {
            throw MaxAccumulationExceededException(
                "1회 최대 적립 금액(${maxAccumulationAmount}원)을 초과했습니다."
            )
        }
        
        // 3. 최대 보유 금액 검증
        val currentBalance = pointAccumulationPersistencePort
            .sumAvailableAmountByMemberId(memberId)
            .toLong()
        val maxBalance = getConfigLongValue("MAX_BALANCE_PER_MEMBER")
        if (currentBalance + amount > maxBalance) {
            throw MaxBalanceExceededException()
        }
        
        // 4. 만료일 계산 및 검증
        val expirationDate = calculateExpirationDate(expirationDays)
        validateExpirationDate(expirationDate)
        
        // 5. 포인트 키 생성
        val pointKey = pointKeyGenerator.generate().value
        
        // 6. 포인트 적립 엔티티 생성
        val accumulation = PointAccumulation(
            pointKey = pointKey,
            memberId = memberId,
            amount = moneyAmount,
            expirationDate = expirationDate,
            isManualGrant = isManualGrant
        )
        
        // 7. 저장
        return pointAccumulationPersistencePort.save(accumulation)
    }
    
    /**
     * 만료일 계산
     */
    private fun calculateExpirationDate(expirationDays: Int?): LocalDate {
        val days = expirationDays ?: getConfigIntValue("DEFAULT_EXPIRATION_DAYS")
        return LocalDate.now().plusDays(days.toLong())
    }
    
    /**
     * 만료일 검증
     */
    private fun validateExpirationDate(expirationDate: LocalDate) {
        val minDays = getConfigIntValue("MIN_EXPIRATION_DAYS")
        val maxDays = getConfigIntValue("MAX_EXPIRATION_DAYS")
        val today = LocalDate.now()
        
        val actualDays = java.time.temporal.ChronoUnit.DAYS.between(today, expirationDate).toInt()
        
        if (actualDays < minDays) {
            throw InvalidExpirationDateException(
                "만료일은 최소 ${minDays}일 이후여야 합니다."
            )
        }
        
        if (actualDays > maxDays) {
            throw InvalidExpirationDateException(
                "만료일은 최대 ${maxDays}일 이하여야 합니다."
            )
        }
    }
    
    /**
     * 설정 값을 Long 타입으로 조회
     */
    private fun getConfigLongValue(configKey: String): Long {
        return pointConfigPort.findByConfigKey(configKey)
            .orElseThrow { IllegalArgumentException("설정을 찾을 수 없습니다: $configKey") }
            .getLongValue()
    }
    
    /**
     * 설정 값을 Int 타입으로 조회
     */
    private fun getConfigIntValue(configKey: String): Int {
        return pointConfigPort.findByConfigKey(configKey)
            .orElseThrow { IllegalArgumentException("설정을 찾을 수 없습니다: $configKey") }
            .getIntValue()
    }
}
```

**주요 책임**:
- 적립 요청 검증
- 설정 조회 및 적용
- 잔액 확인 및 검증
- 포인트 적립 생성 및 저장

#### 3.1.2 적립 취소 처리 로직

```kotlin
override fun cancelAccumulation(
        pointKey: String, 
    reason: String?
): PointAccumulation {
        // 1. 적립 건 조회
    val accumulation = pointAccumulationPersistencePort
            .findByPointKey(pointKey)
        .orElseThrow { IllegalArgumentException("포인트 적립 건을 찾을 수 없습니다: $pointKey") }
    
    // 2. 적립 취소 처리
        accumulation.cancel()
    
    // 3. 저장
    return pointAccumulationPersistencePort.save(accumulation)
}
```

**주요 책임**:
- 적립 건 조회 및 검증
- 취소 가능 여부 확인
- 적립 취소 처리
- 취소 이력 기록

## 4. 포인트 사용 서비스

### 4.1 PointUsageService

#### 4.1.1 사용 처리 로직

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointUsageUseCase
import com.musinsa.payments.point.application.port.output.PointKeyGenerator
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsageDetailPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsagePersistencePort
import com.musinsa.payments.point.domain.service.PointUsagePriorityService

@Transactional
@Service
class PointUsageService(
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointUsagePersistencePort: PointUsagePersistencePort,
    private val pointUsageDetailPersistencePort: PointUsageDetailPersistencePort,
    private val pointKeyGenerator: PointKeyGenerator,
    private val pointUsagePriorityService: PointUsagePriorityService
) : PointUsageUseCase {
    
    override fun use(
        memberId: Long,
        orderNumber: String,
        amount: Long
    ): PointUsage {
        // 1. 사용 금액 검증
        val usageAmount = Money.of(amount)
        if (usageAmount.isLessThanOrEqual(Money.ZERO)) {
            throw IllegalArgumentException("사용 금액은 0보다 커야 합니다.")
        }
        
        // 2. 사용 가능 잔액 확인
        val availableBalance = pointAccumulationPersistencePort
            .sumAvailableAmountByMemberId(memberId)
        
        if (availableBalance.isLessThan(usageAmount)) {
            throw InsufficientPointException()
        }
        
        // 3. 사용 가능한 적립 건 조회
        val availableAccumulations = pointAccumulationPersistencePort
            .findAvailableAccumulationsByMemberId(memberId)
        
        // 4. 포인트 사용 우선순위에 따라 적립 건 선택
        val selectedAccumulations = pointUsagePriorityService.selectAccumulationsForUsage(
            memberId = memberId,
            usageAmount = usageAmount,
            accumulations = availableAccumulations
        )
        
        // 5. 포인트 키 생성
        val pointKey = pointKeyGenerator.generate().value
        
        // 6. 포인트 사용 엔티티 생성 및 저장
        val usage = PointUsage(
            pointKey = pointKey,
            memberId = memberId,
            orderNumber = OrderNumber.of(orderNumber),
            totalAmount = usageAmount
        )
        val savedUsage = pointUsagePersistencePort.save(usage)
        val usageId = savedUsage.id
            ?: throw IllegalStateException("사용 건 ID가 없습니다.")
        
        // 7. 포인트 사용 처리 및 상세 내역 생성
        val usageDetails = mutableListOf<PointUsageDetail>()
        var remainingAmount = usageAmount
        
        for (accumulation in selectedAccumulations) {
            val available = accumulation.availableAmount
            val useAmount = if (remainingAmount.isLessThan(available)) {
                remainingAmount
            } else {
                available
            }
            
            // 적립 건에서 포인트 사용 처리
            accumulation.use(useAmount)
            
            // 1원 단위로 상세 내역 생성
            val details = createUsageDetails(
                pointUsageId = usageId,
                pointAccumulationId = accumulation.id
                    ?: throw IllegalStateException("적립 건 ID가 없습니다."),
                amount = useAmount
            )
            usageDetails.addAll(details)
            
            remainingAmount = remainingAmount.subtract(useAmount)
            
            // 적립 건 저장 (사용 가능 잔액 업데이트)
            pointAccumulationPersistencePort.save(accumulation)
        }
        
        // 8. 상세 내역 저장
        pointUsageDetailPersistencePort.saveAll(usageDetails)
        
        return savedUsage
    }
    
    /**
     * 1원 단위로 사용 상세 내역 생성
     */
    private fun createUsageDetails(
        pointUsageId: Long,
        pointAccumulationId: Long,
        amount: Money
    ): List<PointUsageDetail> {
        val details = mutableListOf<PointUsageDetail>()
        val amountLong = amount.toLong()
        
        // 1원 단위로 상세 내역 생성
        for (i in 0 until amountLong) {
            details.add(
                PointUsageDetail(
                    pointUsageId = pointUsageId,
                    pointAccumulationId = pointAccumulationId,
                    amount = Money.of(1L)
                )
            )
        }
        
        return details
    }
}
```

**주요 책임**:
- 사용 가능한 적립 건 조회
- 우선순위에 따른 적립 건 선택
- 포인트 사용 및 상세 내역 생성
- 적립 건의 사용 가능 잔액 업데이트

#### 4.1.2 사용 우선순위 알고리즘

```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    
    fun selectAccumulationsForUsage(
        memberId: Long,
        usageAmount: Money,
        accumulations: List<PointAccumulation>
    ): List<PointAccumulation> {
        
        // 1. 사용 가능한 적립 건만 필터링
        val available = accumulations
            .filter { it.hasAvailableAmount() }
            .filter { !it.isExpired() }
        
        // 2. 우선순위 정렬
        // 1순위: 수기 지급 포인트 (내림차순)
        // 2순위: 만료일이 짧은 순 (오름차순)
        val sorted = available.sortedWith(
            compareByDescending<PointAccumulation> { it.isManualGrant() }
                .thenBy { it.expirationDate }
        )
        
        // 3. 사용할 적립 건 선택
        return selectAccumulations(sorted, usageAmount)
    }
    
    private fun selectAccumulations(
        accumulations: List<PointAccumulation>,
        usageAmount: Money
    ): List<PointAccumulation> {
        
        val selected = mutableListOf<PointAccumulation>()
        var remaining = usageAmount
        
        for (accumulation in accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val available = accumulation.availableAmount
            val useAmount = if (remaining.isLessThan(available)) {
                remaining
            } else {
                available
            }
            
            selected.add(accumulation)
            remaining = remaining.subtract(useAmount)
        }
        
        // 사용할 포인트가 부족한 경우 예외 발생
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw InsufficientPointException(
                "사용 가능한 포인트가 부족합니다. 부족한 금액: ${remaining.toLong()}원")
        }
        
        return selected
    }
}
```

**우선순위 규칙**:
1. **수기 지급 포인트 우선**: `isManualGrant = true`인 포인트가 먼저 사용됨
2. **만료일 짧은 순**: 만료일이 가까운 포인트가 먼저 사용됨 (FIFO)

## 5. 포인트 취소 서비스

### 5.1 PointCancellationService

#### 5.1.1 사용 취소 처리 로직

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointCancellationUseCase
import com.musinsa.payments.point.application.port.output.PointKeyGenerator
import com.musinsa.payments.point.application.port.output.config.PointConfigPort
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsageDetailPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsagePersistencePort

@Transactional
@Service
class PointCancellationService(
    private val pointUsagePersistencePort: PointUsagePersistencePort,
    private val pointUsageDetailPersistencePort: PointUsageDetailPersistencePort,
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointKeyGenerator: PointKeyGenerator,
    private val pointConfigPort: PointConfigPort
) : PointCancellationUseCase {
    
    override fun cancelUsage(
        pointKey: String, 
        amount: Long?,
        reason: String?
    ): PointUsage {
        // 1. 사용 건 조회
        val usage = pointUsagePersistencePort
            .findByPointKey(pointKey)
            .orElseThrow { IllegalArgumentException("포인트 사용 건을 찾을 수 없습니다: $pointKey") }
        
        // 2. 취소 금액 결정 (null이면 전체 취소)
        val cancelAmount = if (amount != null) {
            Money.of(amount)
        } else {
            usage.getRemainingAmount()
        }
        
        // 3. 취소 가능 여부 확인
        if (!usage.canCancel(cancelAmount)) {
            throw CannotCancelUsageException()
        }
        
        // 4. 사용 상세 내역 조회
        val usageDetails = pointUsageDetailPersistencePort.findByUsagePointKey(pointKey)
        
        // 5. 상세 내역별로 취소 처리 및 적립 건 복원
        var remainingCancelAmount = cancelAmount
        val restoredAccumulations = mutableMapOf<Long, Money>()
        
        for (detail in usageDetails) {
            if (remainingCancelAmount.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val detailRemaining = detail.getRemainingAmount()
            if (detailRemaining.isLessThanOrEqual(Money.ZERO)) {
                continue
            }
            
            val detailCancelAmount = if (remainingCancelAmount.isLessThan(detailRemaining)) {
                remainingCancelAmount
            } else {
                detailRemaining
            }
            
            // 상세 내역 취소 처리
            detail.cancel(detailCancelAmount)
            
            // 적립 건 복원 금액 누적
            val accumulationId = detail.pointAccumulationId
            val currentRestoreAmount = restoredAccumulations.getOrDefault(accumulationId, Money.ZERO)
            restoredAccumulations[accumulationId] = currentRestoreAmount.add(detailCancelAmount)
            
            remainingCancelAmount = remainingCancelAmount.subtract(detailCancelAmount)
        }
        
        // 6. 적립 건 복원 처리 (만료 포인트 확인 및 신규 적립 처리)
        for ((accumulationId, restoreAmount) in restoredAccumulations) {
            restoreAccumulation(accumulationId, restoreAmount)
        }
        
        // 7. 사용 건 취소 처리 및 저장
        usage.cancel(cancelAmount)
        val savedUsage = pointUsagePersistencePort.save(usage)
        pointUsageDetailPersistencePort.saveAll(usageDetails)
        
        return savedUsage
    }
    
    /**
     * 적립 건 복원 처리
     * 만료된 포인트인 경우 신규 적립으로 처리하고, 그렇지 않으면 기존 적립 건 복원
     */
    private fun restoreAccumulation(accumulationId: Long, restoreAmount: Money) {
        // 적립 건 조회
        val accumulation = pointAccumulationPersistencePort
            .findById(accumulationId)
            .orElseThrow { IllegalArgumentException("포인트 적립 건을 찾을 수 없습니다: $accumulationId") }
        
        // 만료 여부 확인
        if (accumulation.isExpired()) {
            // 만료된 포인트는 신규 적립으로 처리
            val newAccumulation = createNewAccumulationForExpiredPoint(
                memberId = accumulation.memberId,
                amount = restoreAmount,
                originalExpirationDate = accumulation.expirationDate
            )
            pointAccumulationPersistencePort.save(newAccumulation)
        } else {
            // 만료되지 않은 포인트는 기존 적립 건 복원
            accumulation.restore(restoreAmount)
            pointAccumulationPersistencePort.save(accumulation)
        }
    }
    
    /**
     * 만료 포인트 확인 및 신규 적립 처리
     */
    private fun createNewAccumulationForExpiredPoint(
        memberId: Long,
        amount: Money,
        originalExpirationDate: LocalDate
    ): PointAccumulation {
        // 만료일이 지났는지 확인
        val today = LocalDate.now()
        require(today.isAfter(originalExpirationDate)) { "만료되지 않은 포인트입니다." }
        
        // 만료된 포인트는 신규 적립으로 처리
        val defaultExpirationDays = getConfigIntValue("DEFAULT_EXPIRATION_DAYS")
        val newExpirationDate = today.plusDays(defaultExpirationDays.toLong())
        
        val pointKey = pointKeyGenerator.generate().value
        
        return PointAccumulation(
            pointKey = pointKey,
            memberId = memberId,
            amount = amount,
            expirationDate = newExpirationDate,
            isManualGrant = false
        )
    }
    
    /**
     * 설정 값을 Int 타입으로 조회
     */
    private fun getConfigIntValue(configKey: String): Int {
        return pointConfigPort.findByConfigKey(configKey)
            .orElseThrow { IllegalArgumentException("설정을 찾을 수 없습니다: $configKey") }
            .getIntValue()
    }
}
```

**주요 책임**:
- 사용 건 조회 및 검증
- 사용 상세 내역 취소 처리
- 만료된 포인트는 신규 적립 처리
- 만료되지 않은 포인트는 사용 가능 잔액 복원

#### 5.1.2 만료 포인트 처리 로직

만료된 포인트를 사용 취소할 때는 다음 로직을 따릅니다:

1. **만료 확인**: 사용 취소 시점에 해당 적립 건이 만료되었는지 확인
2. **신규 적립**: 만료된 포인트는 사용 가능 잔액을 복원할 수 없으므로, 신규 적립으로 처리
3. **만료일 설정**: 신규 적립의 만료일은 기본 만료일로 설정

## 6. 포인트 조회 서비스

### 6.1 PointQueryService

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointQueryUseCase
import com.musinsa.payments.point.application.port.input.PointBalanceResult
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsagePersistencePort
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable

@Transactional(readOnly = true)
@Service
class PointQueryService(
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointUsagePersistencePort: PointUsagePersistencePort
) : PointQueryUseCase {
    
    override fun getBalance(memberId: Long): PointBalanceResult {
        // 1. 적립 내역 조회 (ACCUMULATED 상태만)
        val allAccumulations = pointAccumulationPersistencePort
            .findByMemberIdAndStatus(memberId, PointAccumulationStatus.ACCUMULATED)
        
        // 2. 총 잔액 계산 (모든 적립 금액 합계)
        val totalBalance = allAccumulations
            .sumOf { it.amount.toLong() }
        
        // 3. 사용 가능 잔액 계산 (사용 가능한 적립 건의 사용 가능 잔액 합계)
        val availableBalance = allAccumulations
            .filter { !it.isExpired() }
            .sumOf { it.availableAmount.toLong() }
        
        // 4. 만료 잔액 계산 (만료된 적립 건의 사용 가능 잔액 합계)
        val expiredBalance = allAccumulations
            .filter { it.isExpired() }
            .sumOf { it.availableAmount.toLong() }
        
        return PointBalanceResult(
            memberId = memberId,
            totalBalance = totalBalance,
            availableBalance = availableBalance,
            expiredBalance = expiredBalance,
            accumulations = allAccumulations
        )
    }
    
    override fun getUsageHistory(
        memberId: Long, 
        orderNumber: String?,
        pageable: Pageable
    ): Page<PointUsage> {
        return pointUsagePersistencePort.findUsageHistoryByMemberId(
            memberId = memberId,
            orderNumber = orderNumber,
            pageable = pageable
        )
    }
}
```

## 7. 트랜잭션 경계

### 7.1 트랜잭션 전략

- **서비스 메서드 레벨**: `@Transactional` 어노테이션 사용
- **읽기 전용**: `@Transactional(readOnly = true)` 사용
- **트랜잭션 전파**: 기본값(REQUIRED) 사용

### 7.2 트랜잭션 범위

- **적립**: 적립 건 저장, 설정 조회
- **적립 취소**: 적립 건 업데이트, 취소 이력 저장
- **사용**: 사용 건 저장, 상세 내역 저장, 적립 건 업데이트
- **사용 취소**: 사용 건 업데이트, 상세 내역 업데이트, 적립 건 업데이트/생성, 취소 이력 저장

## 8. 동시성 제어 전략

### 8.1 동시성 이슈 시나리오

- **동일 사용자 동시 포인트 사용**: 여러 요청이 동시에 같은 적립 건을 사용하려는 경우
- **적립과 사용의 동시 발생**: 적립 처리 중에 해당 적립 건 사용 요청이 들어오는 경우
- **사용 취소 동시 요청**: 같은 사용 건에 대해 동시에 취소 요청이 들어오는 경우

### 8.2 해결 전략

#### 8.2.1 비관적 락 (Pessimistic Lock)

```kotlin
interface PointAccumulationPersistencePort {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    fun findByIdWithLock(id: Long): PointAccumulation?

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    fun findAvailableAccumulationsByMemberIdWithLock(memberId: Long): List<PointAccumulation>
}
```

**적용 시점**:
- 포인트 사용 시 적립 건 조회
- 사용 취소 시 적립 건 복원

#### 8.2.2 트랜잭션 격리 수준

```kotlin
@Transactional(isolation = Isolation.READ_COMMITTED)
class PointUsageService : PointUsageUseCase {
    // 기본 격리 수준으로 충분한 경우
}

@Transactional(isolation = Isolation.REPEATABLE_READ)
fun useWithHighIsolation(
    memberId: Long,
    orderNumber: String,
    amount: Long
): PointUsage {
    // 높은 격리 수준이 필요한 경우
}
```

#### 8.2.3 사용자별 락

```kotlin
@Service
class PointUsageService(
    private val lockService: DistributedLockService
) : PointUsageUseCase {
    override fun use(
        memberId: Long,
        orderNumber: String,
        amount: Long
    ): PointUsage {
        val lockKey = "point:use:member:$memberId"
        return lockService.executeWithLock(lockKey, timeout = 5000) {
            executeUse(memberId, orderNumber, amount)
        }
    }
}
```

### 8.3 데드락 방지

- **순서 보장**: 적립 건 조회 시 항상 ID 오름차순으로 정렬하여 락 획득
- **타임아웃 설정**: 락 대기 시간 제한 (5초 권장)
- **락 범위 최소화**: 필요한 최소 범위만 락 적용

## 9. 예외 처리 전략

### 9.1 예외 계층 구조

```
RuntimeException
└── PointDomainException
    ├── InsufficientPointException
    ├── CannotCancelAccumulationException
    ├── CannotCancelUsageException
    ├── InvalidAmountException
    ├── ExceededMaxBalanceException
    └── ...
```

### 8.2 예외 처리 흐름

1. **도메인 예외 발생**: 비즈니스 규칙 위반 시 도메인 예외 발생
2. **서비스 레이어**: 도메인 예외를 그대로 전파
3. **컨트롤러 레이어**: 예외를 HTTP 응답으로 변환

## 9. 다음 단계

다음 단계에서는 설정 관리 설계를 통해 동적 설정 관리 방법을 구체화할 예정입니다.

---

**다음 문서**: [06. 설정 관리 설계](./06-설정-관리-설계.md)

