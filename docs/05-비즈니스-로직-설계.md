# 05. 비즈니스 로직 설계

## 1. 개요

포인트 시스템의 핵심 비즈니스 로직을 설계합니다. 적립, 적립 취소, 사용, 사용 취소의 각 기능별로 서비스 레이어를 구성합니다.

## 2. 서비스 레이어 구조

### 2.1 패키지 구조

```
com.musinsa.payments.point.service
├── PointAccumulationService      # 적립 서비스
├── PointUsageService             # 사용 서비스
├── PointCancellationService      # 취소 서비스
└── PointQueryService             # 조회 서비스
```

## 3. 포인트 적립 서비스

### 3.1 PointAccumulationService

#### 3.1.1 적립 처리 로직

```java
package com.musinsa.payments.point.service;

@Transactional
public class PointAccumulationService {
    
    private final PointAccumulationRepository accumulationRepository;
    private final PointConfigRepository configRepository;
    private final PointAccumulationDomainService domainService;
    private final PointKeyGenerator pointKeyGenerator;
    
    public AccumulatePointResponse accumulate(AccumulatePointRequest request) {
        // 1. 설정 조회
        PointConfig maxAmountConfig = configRepository
            .findByConfigKey("MAX_ACCUMULATION_AMOUNT_PER_TIME")
            .orElseThrow(() -> new ConfigNotFoundException());
        
        PointConfig maxBalanceConfig = configRepository
            .findByConfigKey("MAX_BALANCE_PER_MEMBER")
            .orElseThrow(() -> new ConfigNotFoundException());
        
        PointConfig defaultExpirationDaysConfig = configRepository
            .findByConfigKey("DEFAULT_EXPIRATION_DAYS")
            .orElseThrow(() -> new ConfigNotFoundException());
        
        // 2. 요청 데이터 검증
        Money amount = Money.of(request.getAmount());
        validateAmount(amount, maxAmountConfig.getLongValue());
        
        // 3. 현재 잔액 확인
        Money currentBalance = accumulationRepository
            .calculateTotalBalance(request.getMemberId());
        validateMaxBalance(currentBalance, amount, maxBalanceConfig.getLongValue());
        
        // 4. 만료일 계산
        Integer expirationDays = request.getExpirationDays() != null
            ? request.getExpirationDays()
            : defaultExpirationDaysConfig.getIntValue();
        LocalDate expirationDate = calculateExpirationDate(expirationDays);
        
        // 5. 포인트 적립 생성
        PointAccumulation accumulation = domainService.createAccumulation(
            request.getMemberId(),
            amount,
            expirationDate,
            request.getIsManualGrant() != null && request.getIsManualGrant(),
            pointKeyGenerator
        );
        
        // 6. 저장
        PointAccumulation saved = accumulationRepository.save(accumulation);
        
        // 7. 응답 생성
        return AccumulatePointResponse.from(saved);
    }
    
    private void validateAmount(Money amount, Long maxAmount) {
        if (amount.isLessThan(Money.of(1))) {
            throw new InvalidAmountException("적립 금액은 1원 이상이어야 합니다.");
        }
        if (amount.isGreaterThan(Money.of(maxAmount))) {
            throw new ExceededMaxAccumulationException(
                String.format("1회 최대 적립 금액(%d원)을 초과했습니다.", maxAmount));
        }
    }
    
    private void validateMaxBalance(Money currentBalance, Money newAmount, Long maxBalance) {
        Money totalBalance = currentBalance.add(newAmount);
        if (totalBalance.isGreaterThan(Money.of(maxBalance))) {
            throw new ExceededMaxBalanceException(
                String.format("개인별 최대 보유 금액(%d원)을 초과했습니다.", maxBalance));
        }
    }
    
    private LocalDate calculateExpirationDate(Integer expirationDays) {
        LocalDate now = LocalDate.now();
        LocalDate expirationDate = now.plusDays(expirationDays);
        
        // 만료일 범위 검증
        PointConfig minDaysConfig = configRepository
            .findByConfigKey("MIN_EXPIRATION_DAYS")
            .orElseThrow(() -> new ConfigNotFoundException());
        PointConfig maxDaysConfig = configRepository
            .findByConfigKey("MAX_EXPIRATION_DAYS")
            .orElseThrow(() -> new ConfigNotFoundException());
        
        if (expirationDays < minDaysConfig.getIntValue() 
            || expirationDays >= maxDaysConfig.getIntValue()) {
            throw new InvalidExpirationDateException(
                String.format("만료일은 %d일 이상 %d일 미만이어야 합니다.", 
                    minDaysConfig.getIntValue(), maxDaysConfig.getIntValue()));
        }
        
        return expirationDate;
    }
}
```

**주요 책임**:
- 적립 요청 검증
- 설정 조회 및 적용
- 잔액 확인 및 검증
- 포인트 적립 생성 및 저장

#### 3.1.2 적립 취소 처리 로직

```java
@Transactional
public class PointAccumulationService {
    
    public CancelAccumulationResponse cancelAccumulation(
            String pointKey, 
            CancelAccumulationRequest request) {
        
        // 1. 적립 건 조회
        PointAccumulation accumulation = accumulationRepository
            .findByPointKey(pointKey)
            .orElseThrow(() -> new AccumulationNotFoundException());
        
        // 2. 취소 가능 여부 확인
        if (!accumulation.canBeCancelled()) {
            throw new CannotCancelAccumulationException();
        }
        
        // 3. 적립 취소 처리
        accumulation.cancel();
        accumulationRepository.save(accumulation);
        
        // 4. 취소 이력 기록
        PointCancellation cancellation = PointCancellation.builder()
            .pointKey(pointKeyGenerator.generate())
            .cancellationType(CancellationType.ACCUMULATION_CANCELLATION)
            .targetPointKey(pointKey)
            .memberId(accumulation.getMemberId())
            .amount(accumulation.getAmount())
            .reason(request.getReason())
            .build();
        
        cancellationRepository.save(cancellation);
        
        // 5. 응답 생성
        return CancelAccumulationResponse.from(cancellation);
    }
}
```

**주요 책임**:
- 적립 건 조회 및 검증
- 취소 가능 여부 확인
- 적립 취소 처리
- 취소 이력 기록

## 4. 포인트 사용 서비스

### 4.1 PointUsageService

#### 4.1.1 사용 처리 로직

```java
package com.musinsa.payments.point.service;

@Transactional
public class PointUsageService {
    
    private final PointAccumulationRepository accumulationRepository;
    private final PointUsageRepository usageRepository;
    private final PointUsageDetailRepository detailRepository;
    private final PointUsagePriorityService priorityService;
    private final PointKeyGenerator pointKeyGenerator;
    
    public UsePointResponse use(UsePointRequest request) {
        // 1. 사용 가능한 적립 건 조회
        List<PointAccumulation> accumulations = accumulationRepository
            .findAvailableByMemberId(request.getMemberId());
        
        // 2. 사용할 적립 건 선택 (우선순위 적용)
        Money usageAmount = Money.of(request.getAmount());
        List<PointAccumulation> selectedAccumulations = priorityService
            .selectAccumulationsForUsage(
                request.getMemberId(),
                usageAmount,
                accumulations
            );
        
        // 3. 포인트 사용 생성
        PointUsage usage = PointUsage.builder()
            .pointKey(pointKeyGenerator.generate())
            .memberId(request.getMemberId())
            .orderNumber(OrderNumber.of(request.getOrderNumber()))
            .totalAmount(usageAmount)
            .cancelledAmount(Money.ZERO)
            .status(PointUsageStatus.USED)
            .build();
        
        PointUsage savedUsage = usageRepository.save(usage);
        
        // 4. 사용 상세 내역 생성 및 저장
        List<PointUsageDetail> details = createUsageDetails(
            savedUsage,
            selectedAccumulations,
            usageAmount
        );
        detailRepository.saveAll(details);
        
        // 5. 적립 건의 사용 가능 잔액 차감
        updateAccumulationAvailableAmounts(selectedAccumulations, details);
        selectedAccumulations.forEach(accumulationRepository::save);
        
        // 6. 응답 생성
        return UsePointResponse.from(savedUsage, details);
    }
    
    private List<PointUsageDetail> createUsageDetails(
            PointUsage usage,
            List<PointAccumulation> accumulations,
            Money totalUsageAmount) {
        
        List<PointUsageDetail> details = new ArrayList<>();
        Money remaining = totalUsageAmount;
        
        for (PointAccumulation accumulation : accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break;
            }
            
            Money available = accumulation.getAvailableAmount();
            Money useAmount = remaining.isLessThan(available) 
                ? remaining 
                : available;
            
            PointUsageDetail detail = PointUsageDetail.builder()
                .pointUsageId(usage.getId())
                .pointAccumulationId(accumulation.getId())
                .amount(useAmount)
                .cancelledAmount(Money.ZERO)
                .build();
            
            details.add(detail);
            remaining = remaining.subtract(useAmount);
        }
        
        return details;
    }
    
    private void updateAccumulationAvailableAmounts(
            List<PointAccumulation> accumulations,
            List<PointUsageDetail> details) {
        
        Map<Long, Money> usageAmountMap = details.stream()
            .collect(Collectors.groupingBy(
                PointUsageDetail::getPointAccumulationId,
                Collectors.reducing(
                    Money.ZERO,
                    PointUsageDetail::getAmount,
                    Money::add
                )
            ));
        
        for (PointAccumulation accumulation : accumulations) {
            Money usageAmount = usageAmountMap.getOrDefault(
                accumulation.getId(), 
                Money.ZERO
            );
            accumulation.use(usageAmount);
        }
    }
}
```

**주요 책임**:
- 사용 가능한 적립 건 조회
- 우선순위에 따른 적립 건 선택
- 포인트 사용 및 상세 내역 생성
- 적립 건의 사용 가능 잔액 업데이트

#### 4.1.2 사용 우선순위 알고리즘

```java
package com.musinsa.payments.point.domain.service;

public class PointUsagePriorityService {
    
    public List<PointAccumulation> selectAccumulationsForUsage(
            Long memberId,
            Money usageAmount,
            List<PointAccumulation> accumulations) {
        
        // 1. 사용 가능한 적립 건만 필터링
        List<PointAccumulation> available = accumulations.stream()
            .filter(PointAccumulation::hasAvailableAmount)
            .filter(acc -> !acc.isExpired())
            .collect(Collectors.toList());
        
        // 2. 우선순위 정렬
        // 1순위: 수기 지급 포인트 (내림차순)
        // 2순위: 만료일이 짧은 순 (오름차순)
        available.sort(Comparator
            .comparing((PointAccumulation acc) -> acc.isManualGrant())
                .reversed()  // 수기 지급이 true인 것이 먼저
            .thenComparing(PointAccumulation::getExpirationDate));  // 만료일 짧은 순
        
        // 3. 사용할 적립 건 선택
        return selectAccumulations(available, usageAmount);
    }
    
    private List<PointAccumulation> selectAccumulations(
            List<PointAccumulation> accumulations,
            Money usageAmount) {
        
        List<PointAccumulation> selected = new ArrayList<>();
        Money remaining = usageAmount;
        
        for (PointAccumulation accumulation : accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break;
            }
            
            Money available = accumulation.getAvailableAmount();
            Money useAmount = remaining.isLessThan(available) 
                ? remaining 
                : available;
            
            selected.add(accumulation);
            remaining = remaining.subtract(useAmount);
        }
        
        // 사용할 포인트가 부족한 경우 예외 발생
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw new InsufficientPointException(
                String.format("사용 가능한 포인트가 부족합니다. 부족한 금액: %d원", 
                    remaining.toLong()));
        }
        
        return selected;
    }
}
```

**우선순위 규칙**:
1. **수기 지급 포인트 우선**: `isManualGrant = true`인 포인트가 먼저 사용됨
2. **만료일 짧은 순**: 만료일이 가까운 포인트가 먼저 사용됨 (FIFO)

## 5. 포인트 취소 서비스

### 5.1 PointCancellationService

#### 5.1.1 사용 취소 처리 로직

```java
package com.musinsa.payments.point.service;

@Transactional
public class PointCancellationService {
    
    private final PointUsageRepository usageRepository;
    private final PointUsageDetailRepository detailRepository;
    private final PointAccumulationRepository accumulationRepository;
    private final PointAccumulationService accumulationService;
    private final PointKeyGenerator pointKeyGenerator;
    private final PointCancellationRepository cancellationRepository;
    
    public CancelUsageResponse cancelUsage(
            String pointKey, 
            CancelUsageRequest request) {
        
        // 1. 사용 건 조회
        PointUsage usage = usageRepository
            .findByPointKey(pointKey)
            .orElseThrow(() -> new UsageNotFoundException());
        
        // 2. 취소 금액 결정
        Money cancelAmount = request.getAmount() != null
            ? Money.of(request.getAmount())
            : usage.getRemainingAmount();
        
        // 3. 취소 가능 여부 확인
        if (!usage.canCancel(cancelAmount)) {
            throw new CannotCancelUsageException();
        }
        
        // 4. 사용 상세 내역 조회
        List<PointUsageDetail> details = detailRepository
            .findByPointUsageId(usage.getId());
        
        // 5. 사용 취소 처리
        usage.cancel(cancelAmount);
        usageRepository.save(usage);
        
        // 6. 상세 내역 취소 처리 및 적립 건 복원
        List<NewAccumulationInfo> newAccumulations = processUsageDetailsCancellation(
            details,
            cancelAmount,
            usage.getMemberId()
        );
        
        // 7. 취소 이력 기록
        PointCancellation cancellation = PointCancellation.builder()
            .pointKey(pointKeyGenerator.generate())
            .cancellationType(CancellationType.USAGE_CANCELLATION)
            .targetPointKey(pointKey)
            .memberId(usage.getMemberId())
            .amount(cancelAmount)
            .reason(request.getReason())
            .build();
        
        cancellationRepository.save(cancellation);
        
        // 8. 응답 생성
        return CancelUsageResponse.from(cancellation, newAccumulations);
    }
    
    private List<NewAccumulationInfo> processUsageDetailsCancellation(
            List<PointUsageDetail> details,
            Money cancelAmount,
            Long memberId) {
        
        List<NewAccumulationInfo> newAccumulations = new ArrayList<>();
        Money remaining = cancelAmount;
        
        // 역순으로 처리 (나중에 사용한 것부터 취소)
        Collections.reverse(details);
        
        for (PointUsageDetail detail : details) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break;
            }
            
            Money detailRemaining = detail.getRemainingAmount();
            Money cancelDetailAmount = remaining.isLessThan(detailRemaining)
                ? remaining
                : detailRemaining;
            
            // 상세 내역 취소 처리
            detail.cancel(cancelDetailAmount);
            detailRepository.save(detail);
            
            // 적립 건 조회
            PointAccumulation accumulation = accumulationRepository
                .findById(detail.getPointAccumulationId())
                .orElseThrow(() -> new AccumulationNotFoundException());
            
            // 만료 여부 확인
            LocalDate now = LocalDate.now();
            if (accumulation.isExpiredAt(now)) {
                // 만료된 포인트는 신규 적립 처리
                PointAccumulation newAccumulation = createNewAccumulationForExpired(
                    memberId,
                    cancelDetailAmount,
                    accumulation
                );
                PointAccumulation saved = accumulationRepository.save(newAccumulation);
                newAccumulations.add(NewAccumulationInfo.from(saved));
            } else {
                // 만료되지 않은 포인트는 사용 가능 잔액 복원
                accumulation.restore(cancelDetailAmount);
                accumulationRepository.save(accumulation);
            }
            
            remaining = remaining.subtract(cancelDetailAmount);
        }
        
        return newAccumulations;
    }
    
    private PointAccumulation createNewAccumulationForExpired(
            Long memberId,
            Money amount,
            PointAccumulation originalAccumulation) {
        
        // 기본 만료일 조회
        PointConfig defaultExpirationDaysConfig = configRepository
            .findByConfigKey("DEFAULT_EXPIRATION_DAYS")
            .orElseThrow(() -> new ConfigNotFoundException());
        
        LocalDate expirationDate = LocalDate.now()
            .plusDays(defaultExpirationDaysConfig.getIntValue());
        
        return domainService.createAccumulation(
            memberId,
            amount,
            expirationDate,
            false,  // 만료 포인트로 인한 신규 적립은 수기 지급 아님
            pointKeyGenerator
        );
    }
}
```

**주요 책임**:
- 사용 건 조회 및 검증
- 사용 상세 내역 취소 처리
- 만료된 포인트는 신규 적립 처리
- 만료되지 않은 포인트는 사용 가능 잔액 복원

#### 5.1.2 만료 포인트 처리 로직

만료된 포인트를 사용 취소할 때는 다음 로직을 따릅니다:

1. **만료 확인**: 사용 취소 시점에 해당 적립 건이 만료되었는지 확인
2. **신규 적립**: 만료된 포인트는 사용 가능 잔액을 복원할 수 없으므로, 신규 적립으로 처리
3. **만료일 설정**: 신규 적립의 만료일은 기본 만료일로 설정

## 6. 포인트 조회 서비스

### 6.1 PointQueryService

```java
package com.musinsa.payments.point.service;

@Transactional(readOnly = true)
public class PointQueryService {
    
    private final PointAccumulationRepository accumulationRepository;
    private final PointUsageRepository usageRepository;
    private final PointUsageDetailRepository detailRepository;
    
    public PointBalanceResponse getBalance(Long memberId) {
        // 1. 적립 건 조회
        List<PointAccumulation> accumulations = accumulationRepository
            .findByMemberId(memberId);
        
        // 2. 잔액 계산
        Money totalBalance = accumulationRepository
            .calculateTotalBalance(memberId);
        Money availableBalance = accumulationRepository
            .calculateAvailableBalance(memberId);
        
        // 3. 만료된 포인트 금액 계산
        Money expiredBalance = accumulations.stream()
            .filter(PointAccumulation::isExpired)
            .map(PointAccumulation::getAmount)
            .reduce(Money.ZERO, Money::add);
        
        // 4. 응답 생성
        return PointBalanceResponse.builder()
            .memberId(memberId)
            .totalBalance(totalBalance.toLong())
            .availableBalance(availableBalance.toLong())
            .expiredBalance(expiredBalance.toLong())
            .accumulations(accumulations.stream()
                .map(AccumulationSummaryResponse::from)
                .collect(Collectors.toList()))
            .build();
    }
    
    public PointHistoryResponse getHistory(
            Long memberId, 
            String orderNumber,
            Pageable pageable) {
        
        // 1. 사용 건 조회
        List<PointUsage> usages;
        if (orderNumber != null) {
            usages = usageRepository.findByOrderNumber(orderNumber);
        } else {
            usages = usageRepository.findByMemberId(memberId);
        }
        
        // 2. 페이징 처리
        int start = (int) pageable.getOffset();
        int end = Math.min((start + pageable.getPageSize()), usages.size());
        List<PointUsage> pagedUsages = usages.subList(start, end);
        
        // 3. 사용 상세 내역 조회
        List<UsageHistoryResponse> history = pagedUsages.stream()
            .map(usage -> {
                List<PointUsageDetail> details = detailRepository
                    .findByPointUsageId(usage.getId());
                return UsageHistoryResponse.from(usage, details);
            })
            .collect(Collectors.toList());
        
        // 4. 응답 생성
        return PointHistoryResponse.builder()
            .content(history)
            .page(PageInfo.from(usages.size(), pageable))
            .build();
    }
}
```

## 7. 트랜잭션 경계

### 7.1 트랜잭션 전략

- **서비스 메서드 레벨**: `@Transactional` 어노테이션 사용
- **읽기 전용**: `@Transactional(readOnly = true)` 사용
- **트랜잭션 전파**: 기본값(REQUIRED) 사용

### 7.2 트랜잭션 범위

- **적립**: 적립 건 저장, 설정 조회
- **적립 취소**: 적립 건 업데이트, 취소 이력 저장
- **사용**: 사용 건 저장, 상세 내역 저장, 적립 건 업데이트
- **사용 취소**: 사용 건 업데이트, 상세 내역 업데이트, 적립 건 업데이트/생성, 취소 이력 저장

## 8. 예외 처리 전략

### 8.1 예외 계층 구조

```
RuntimeException
└── PointDomainException
    ├── InsufficientPointException
    ├── CannotCancelAccumulationException
    ├── CannotCancelUsageException
    ├── InvalidAmountException
    ├── ExceededMaxBalanceException
    └── ...
```

### 8.2 예외 처리 흐름

1. **도메인 예외 발생**: 비즈니스 규칙 위반 시 도메인 예외 발생
2. **서비스 레이어**: 도메인 예외를 그대로 전파
3. **컨트롤러 레이어**: 예외를 HTTP 응답으로 변환

## 9. 다음 단계

다음 단계에서는 설정 관리 설계를 통해 동적 설정 관리 방법을 구체화할 예정입니다.


