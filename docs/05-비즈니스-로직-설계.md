# 05. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì„¤ê³„

## 1. ê°œìš”

í¬ì¸íŠ¸ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì„¤ê³„í•©ë‹ˆë‹¤. ì ë¦½, ì ë¦½ ì·¨ì†Œ, ì‚¬ìš©, ì‚¬ìš© ì·¨ì†Œì˜ ê° ê¸°ëŠ¥ë³„ë¡œ ì„œë¹„ìŠ¤ ë ˆì´ì–´ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

## 2. ì„œë¹„ìŠ¤ ë ˆì´ì–´ êµ¬ì¡°

### 2.1 íŒ¨í‚¤ì§€ êµ¬ì¡°

```
com.musinsa.payments.point.application
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ PointAccumulationService      # ì ë¦½ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ PointUsageService             # ì‚¬ìš© ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ PointCancellationService      # ì·¨ì†Œ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ PointQueryService             # ì¡°íšŒ ì„œë¹„ìŠ¤
â”‚   â””â”€â”€ PointBalanceReconciliationService  # ì”ì•¡ ì •í•©ì„± ë³´ì • ì„œë¹„ìŠ¤
â””â”€â”€ event/
    â””â”€â”€ PointBalanceEventHandler      # ì”ì•¡ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ë¹„ë™ê¸°)
```

### 2.2 ì´ë²¤íŠ¸ ê¸°ë°˜ ì”ì•¡ ê´€ë¦¬

í¬ì¸íŠ¸ ê±°ë˜(ì ë¦½/ì‚¬ìš©/ì·¨ì†Œ) ë°œìƒ ì‹œ `MemberPointBalance` ìºì‹œ í…Œì´ë¸”ì„ ë¹„ë™ê¸°ë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

```
[í¬ì¸íŠ¸ ì„œë¹„ìŠ¤] â”€â”€â”€ íŠ¸ëœì­ì…˜ ì»¤ë°‹ â”€â”€â”€â†’ [ì´ë²¤íŠ¸ ë°œí–‰] â”€â”€â”€ ë¹„ë™ê¸° â”€â”€â”€â†’ [PointBalanceEventHandler]
                                                                              â”‚
                                                                              â†“
                                                                    [MemberPointBalance ì—…ë°ì´íŠ¸]
```

- **@TransactionalEventListener(AFTER_COMMIT)**: ì›ë³¸ íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ì´ë²¤íŠ¸ ì²˜ë¦¬
- **@Async**: ë¹„ë™ê¸° ì‹¤í–‰ìœ¼ë¡œ ë©”ì¸ ì‘ë‹µ ì‹œê°„ì— ì˜í–¥ ì—†ìŒ
- **ìºì‹œ í…Œì´ë¸”**: ë¹ ë¥¸ ì”ì•¡ ì¡°íšŒë¥¼ ìœ„í•œ O(1) ì¡°íšŒ ì§€ì›

> ğŸ“Œ ìì„¸í•œ ë‚´ìš©ì€ [09. í–¥í›„ ê°œì„  ì‚¬í•­](./09-í–¥í›„-ê°œì„ -ì‚¬í•­.md)ì˜ "Transactional Outbox Pattern" ì„¹ì…˜ì„ ì°¸ì¡°í•˜ì„¸ìš”.

## 3. í¬ì¸íŠ¸ ì ë¦½ ì„œë¹„ìŠ¤

### 3.1 PointAccumulationService

#### 3.1.1 ì ë¦½ ì²˜ë¦¬ ë¡œì§

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointAccumulationUseCase
import com.musinsa.payments.point.application.port.output.PointKeyGenerator
import com.musinsa.payments.point.application.port.output.config.PointConfigPort
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort

@Transactional
@Service
class PointAccumulationService(
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointConfigPort: PointConfigPort,
    private val pointKeyGenerator: PointKeyGenerator
) : PointAccumulationUseCase {
    
    override fun accumulate(
        memberId: Long,
        amount: Long,
        expirationDays: Int?,
        isManualGrant: Boolean
    ): PointAccumulation {
        // 1. ì ë¦½ ê¸ˆì•¡ ê²€ì¦
        val moneyAmount = Money.of(amount)
        if (moneyAmount.isLessThanOrEqual(Money.ZERO)) {
            throw InvalidAmountException("ì ë¦½ ê¸ˆì•¡ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.")
        }
        
        // 2. ìµœëŒ€ ì ë¦½ ê¸ˆì•¡ ê²€ì¦
        val maxAccumulationAmount = getConfigLongValue("MAX_ACCUMULATION_AMOUNT_PER_TIME")
        if (amount > maxAccumulationAmount) {
            throw MaxAccumulationExceededException(
                "1íšŒ ìµœëŒ€ ì ë¦½ ê¸ˆì•¡(${maxAccumulationAmount}ì›)ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤."
            )
        }
        
        // 3. ìµœëŒ€ ë³´ìœ  ê¸ˆì•¡ ê²€ì¦
        val currentBalance = pointAccumulationPersistencePort
            .sumAvailableAmountByMemberId(memberId)
            .toLong()
        val maxBalance = getConfigLongValue("MAX_BALANCE_PER_MEMBER")
        if (currentBalance + amount > maxBalance) {
            throw MaxBalanceExceededException()
        }
        
        // 4. ë§Œë£Œì¼ ê³„ì‚° ë° ê²€ì¦
        val expirationDate = calculateExpirationDate(expirationDays)
        validateExpirationDate(expirationDate)
        
        // 5. í¬ì¸íŠ¸ í‚¤ ìƒì„±
        val pointKey = pointKeyGenerator.generate().value
        
        // 6. í¬ì¸íŠ¸ ì ë¦½ ì—”í‹°í‹° ìƒì„±
        val accumulation = PointAccumulation(
            pointKey = pointKey,
            memberId = memberId,
            amount = moneyAmount,
            expirationDate = expirationDate,
            isManualGrant = isManualGrant
        )
        
        // 7. ì €ì¥
        return pointAccumulationPersistencePort.save(accumulation)
    }
    
    /**
     * ë§Œë£Œì¼ ê³„ì‚°
     */
    private fun calculateExpirationDate(expirationDays: Int?): LocalDate {
        val days = expirationDays ?: getConfigIntValue("DEFAULT_EXPIRATION_DAYS")
        return LocalDate.now().plusDays(days.toLong())
    }
    
    /**
     * ë§Œë£Œì¼ ê²€ì¦
     */
    private fun validateExpirationDate(expirationDate: LocalDate) {
        val minDays = getConfigIntValue("MIN_EXPIRATION_DAYS")
        val maxDays = getConfigIntValue("MAX_EXPIRATION_DAYS")
        val today = LocalDate.now()
        
        val actualDays = java.time.temporal.ChronoUnit.DAYS.between(today, expirationDate).toInt()
        
        if (actualDays < minDays) {
            throw InvalidExpirationDateException(
                "ë§Œë£Œì¼ì€ ìµœì†Œ ${minDays}ì¼ ì´í›„ì—¬ì•¼ í•©ë‹ˆë‹¤."
            )
        }
        
        if (actualDays > maxDays) {
            throw InvalidExpirationDateException(
                "ë§Œë£Œì¼ì€ ìµœëŒ€ ${maxDays}ì¼ ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤."
            )
        }
    }
    
    /**
     * ì„¤ì • ê°’ì„ Long íƒ€ì…ìœ¼ë¡œ ì¡°íšŒ
     */
    private fun getConfigLongValue(configKey: String): Long {
        return pointConfigPort.findByConfigKey(configKey)
            .orElseThrow { IllegalArgumentException("ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $configKey") }
            .getLongValue()
    }
    
    /**
     * ì„¤ì • ê°’ì„ Int íƒ€ì…ìœ¼ë¡œ ì¡°íšŒ
     */
    private fun getConfigIntValue(configKey: String): Int {
        return pointConfigPort.findByConfigKey(configKey)
            .orElseThrow { IllegalArgumentException("ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $configKey") }
            .getIntValue()
    }
}
```

**ì£¼ìš” ì±…ì„**:
- ì ë¦½ ìš”ì²­ ê²€ì¦
- ì„¤ì • ì¡°íšŒ ë° ì ìš©
- ì”ì•¡ í™•ì¸ ë° ê²€ì¦
- í¬ì¸íŠ¸ ì ë¦½ ìƒì„± ë° ì €ì¥

#### 3.1.2 ì ë¦½ ì·¨ì†Œ ì²˜ë¦¬ ë¡œì§

```kotlin
override fun cancelAccumulation(
        pointKey: String, 
    reason: String?
): PointAccumulation {
        // 1. ì ë¦½ ê±´ ì¡°íšŒ
    val accumulation = pointAccumulationPersistencePort
            .findByPointKey(pointKey)
        .orElseThrow { IllegalArgumentException("í¬ì¸íŠ¸ ì ë¦½ ê±´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $pointKey") }
    
    // 2. ì ë¦½ ì·¨ì†Œ ì²˜ë¦¬
        accumulation.cancel()
    
    // 3. ì €ì¥
    return pointAccumulationPersistencePort.save(accumulation)
}
```

**ì£¼ìš” ì±…ì„**:
- ì ë¦½ ê±´ ì¡°íšŒ ë° ê²€ì¦
- ì·¨ì†Œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
- ì ë¦½ ì·¨ì†Œ ì²˜ë¦¬
- ì·¨ì†Œ ì´ë ¥ ê¸°ë¡

## 4. í¬ì¸íŠ¸ ì‚¬ìš© ì„œë¹„ìŠ¤

### 4.1 PointUsageService

#### 4.1.1 ì‚¬ìš© ì²˜ë¦¬ ë¡œì§

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointUsageUseCase
import com.musinsa.payments.point.application.port.output.PointKeyGenerator
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsageDetailPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsagePersistencePort
import com.musinsa.payments.point.domain.entity.PointAccumulation
import com.musinsa.payments.point.domain.entity.PointUsage
import com.musinsa.payments.point.domain.entity.PointUsageDetail
import com.musinsa.payments.point.domain.exception.InsufficientPointException
import com.musinsa.payments.point.domain.service.PointUsagePriorityService
import com.musinsa.payments.point.domain.valueobject.Money
import com.musinsa.payments.point.domain.valueobject.OrderNumber
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Isolation
import org.springframework.transaction.annotation.Transactional

/**
 * í¬ì¸íŠ¸ ì‚¬ìš© ì„œë¹„ìŠ¤: PointUsageUseCase ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì²´
 * 
 * íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€: READ_COMMITTED
 * - í¬ì¸íŠ¸ ì‚¬ìš©ì€ ë™ì‹œì„± ì œì–´ê°€ ì¤‘ìš”í•œ ì‘ì—…
 * - ë¹„ê´€ì  ë½ì„ í†µí•´ ì ë¦½ ê±´ì˜ ë™ì‹œ ì ‘ê·¼ ì œì–´ êµ¬í˜„
 * - READ_COMMITTED ì ìš©í•˜ì—¬ Dirty-Readë¥¼ ë°©ì§€í•˜ë©´ì„œë„, ê³¼ë„í•œ ê²©ë¦¬ë¡œ ì¸í•œ ì„±ëŠ¥ ì €í•˜ ë°©ì§€
 */
@Transactional(isolation = Isolation.READ_COMMITTED)
@Service
class PointUsageService(
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointUsagePersistencePort: PointUsagePersistencePort,
    private val pointUsageDetailPersistencePort: PointUsageDetailPersistencePort,
    private val pointKeyGenerator: PointKeyGenerator,
    private val pointUsagePriorityService: PointUsagePriorityService
) : PointUsageUseCase {
    
    override fun use(
        memberId: Long,
        orderNumber: String,
        amount: Long
    ): PointUsage {
        // 1. ì‚¬ìš© ê¸ˆì•¡ ê²€ì¦
        val usageAmount = Money.of(amount)
        if (usageAmount.isLessThanOrEqual(Money.ZERO)) {
            throw IllegalArgumentException("ì‚¬ìš© ê¸ˆì•¡ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.")
        }
        
        // 2. ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ í™•ì¸
        val availableBalance = pointAccumulationPersistencePort.sumAvailableAmountByMemberId(memberId)
        if (availableBalance.isLessThan(usageAmount)) {
            throw InsufficientPointException()
        }
        
        // 3. ì‚¬ìš© ê°€ëŠ¥í•œ ì ë¦½ ê±´ ì¡°íšŒ (ë¹„ê´€ì  ë½ ì ìš©)
        val availableAccumulations = pointAccumulationPersistencePort
            .findAvailableAccumulationsByMemberIdWithLock(memberId)
        
        // 4. í¬ì¸íŠ¸ ì‚¬ìš© ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì ë¦½ ê±´ ì„ íƒ
        val selectedAccumulations = pointUsagePriorityService.selectAccumulationsForUsage(
            memberId = memberId,
            usageAmount = usageAmount,
            accumulations = availableAccumulations
        )
        
        // 5. í¬ì¸íŠ¸ ì‚¬ìš© ì—”í‹°í‹° ìƒì„± ë° ì €ì¥
        val savedUsage = createAndSavePointUsage(memberId, orderNumber, usageAmount)
        
        // 6. í¬ì¸íŠ¸ ì‚¬ìš© ì²˜ë¦¬ ë° ìƒì„¸ ë‚´ì—­ ìƒì„±
        val usageDetails = processAccumulationsForUsage(
            accumulations = selectedAccumulations,
            usage = savedUsage,
            totalUsageAmount = usageAmount
        )
        
        // 7. ìƒì„¸ ë‚´ì—­ ì €ì¥
        pointUsageDetailPersistencePort.saveAll(usageDetails)
        
        return savedUsage
    }
    
    /**
     * í¬ì¸íŠ¸ ì‚¬ìš© ì—”í‹°í‹° ìƒì„± ë° ì €ì¥
     */
    private fun createAndSavePointUsage(
        memberId: Long,
        orderNumber: String,
        usageAmount: Money
    ): PointUsage {
        val pointKey = pointKeyGenerator.generate().value
        val usage = PointUsage(
            pointKey = pointKey,
            memberId = memberId,
            orderNumber = OrderNumber.of(orderNumber),
            totalAmount = usageAmount
        )
        return pointUsagePersistencePort.save(usage)
    }
    
    /**
     * ì„ íƒëœ ì ë¦½ ê±´ë“¤ì„ ìˆœíšŒí•˜ë©° í¬ì¸íŠ¸ ì‚¬ìš© ì²˜ë¦¬ ë° ìƒì„¸ ë‚´ì—­ ìƒì„±
     * 
     * ì ë¦½ ê±´ì€ ìƒíƒœ ë³€ê²½ í›„ saveAllì„ í†µí•´ ë°°ì¹˜ ì²˜ë¦¬ë¡œ ì¼ê´„ ì €ì¥í•©ë‹ˆë‹¤.
     * 
     * @param accumulations ì‚¬ìš©í•  ì ë¦½ ê±´ ëª©ë¡
     * @param usage í¬ì¸íŠ¸ ì‚¬ìš© ê±´
     * @param totalUsageAmount ì´ ì‚¬ìš© ê¸ˆì•¡
     * @return ìƒì„±ëœ ìƒì„¸ ë‚´ì—­ ëª©ë¡
     */
    private fun processAccumulationsForUsage(
        accumulations: List<PointAccumulation>,
        usage: PointUsage,
        totalUsageAmount: Money
    ): List<PointUsageDetail> {
        data class ProcessingState(
            val remainingAmount: Money,
            val usageDetails: List<PointUsageDetail>,
            val updatedAccumulations: List<PointAccumulation>
        )

        val usageId = usage.id ?: throw IllegalStateException("ì‚¬ìš© ê±´ IDê°€ ì—†ìŠµë‹ˆë‹¤.")

        val initState = ProcessingState(
            remainingAmount = totalUsageAmount,
            usageDetails = emptyList(),
            updatedAccumulations = emptyList()
        )
        
        val finalState = accumulations.fold(initial = initState) { state, accumulation ->
            val accumulationId = accumulation.id ?: throw IllegalStateException("ì ë¦½ ê±´ IDê°€ ì—†ìŠµë‹ˆë‹¤.")
            val useAmount = calculateUseAmount(state.remainingAmount, accumulation.availableAmount)

            // ì ë¦½ ê±´ì—ì„œ í¬ì¸íŠ¸ ì‚¬ìš© ì²˜ë¦¬
            accumulation.use(useAmount)

            // ìƒì„¸ ë‚´ì—­ ìƒì„± ë° ì¶”ê°€
            val detail = createUsageDetail(
                pointUsageId = usageId,
                pointAccumulationId = accumulationId,
                amount = useAmount
            )

            ProcessingState(
                remainingAmount = state.remainingAmount.subtract(useAmount),
                usageDetails = state.usageDetails + detail,
                updatedAccumulations = state.updatedAccumulations + accumulation
            )
        }
        
        // ì ë¦½ ê±´ ì¼ê´„ ì €ì¥ (ë°°ì¹˜ ì²˜ë¦¬)
        if (finalState.updatedAccumulations.isNotEmpty()) {
            pointAccumulationPersistencePort.saveAll(finalState.updatedAccumulations)
        }
        
        return finalState.usageDetails
    }
    
    /**
     * ì ë¦½ ê±´ì—ì„œ ì‚¬ìš©í•  ê¸ˆì•¡ ê³„ì‚°
     */
    private fun calculateUseAmount(remainingAmount: Money, availableAmount: Money): Money {
        return if (remainingAmount.isLessThan(availableAmount)) {
            remainingAmount
        } else {
            availableAmount
        }
    }
    
    /**
     * ì ë¦½ ê±´ë³„ ì‚¬ìš© ìƒì„¸ ë‚´ì—­ ìƒì„±
     *
     * ìš”êµ¬ì‚¬í•­: "íŠ¹ì • ì‹œì ì— ì ë¦½ëœ í¬ì¸íŠ¸ëŠ” 1ì› ë‹¨ìœ„ê¹Œì§€ ì–´ë–¤ ì£¼ë¬¸ì—ì„œ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ ì¶”ì í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤"
     * - ê° ì ë¦½ ê±´ë‹¹ 1ê°œì˜ ë ˆì½”ë“œë¡œ 1ì› ë‹¨ìœ„ ì •í™•ë„ ì¶”ì  ë‹¬ì„±
     * - ì„±ëŠ¥ ìµœì í™”: ì‚¬ìš© ê¸ˆì•¡ë§Œí¼ ë ˆì½”ë“œ ìƒì„± â†’ ì ë¦½ ê±´ë‹¹ 1ê°œ ë ˆì½”ë“œë¡œ ê°œì„ 
     */
    private fun createUsageDetail(
        pointUsageId: Long,
        pointAccumulationId: Long,
        amount: Money
    ): PointUsageDetail {
        return PointUsageDetail(
            pointUsageId = pointUsageId,
            pointAccumulationId = pointAccumulationId,
            amount = amount
        )
    }
}
```

**ì£¼ìš” ì±…ì„**:
- ì‚¬ìš© ê°€ëŠ¥í•œ ì ë¦½ ê±´ ì¡°íšŒ (ë¹„ê´€ì  ë½ ì ìš©)
- ìš°ì„ ìˆœìœ„ì— ë”°ë¥¸ ì ë¦½ ê±´ ì„ íƒ
- í¬ì¸íŠ¸ ì‚¬ìš© ë° ì ë¦½ ê±´ë³„ ìƒì„¸ ë‚´ì—­ ìƒì„±
- ì ë¦½ ê±´ì˜ ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ ì—…ë°ì´íŠ¸ (ë°°ì¹˜ ì²˜ë¦¬)

**ì„±ëŠ¥ ìµœì í™”**:
- **ìƒì„¸ ë‚´ì—­ ì €ì¥ ìµœì í™”**: 1ì› ë‹¨ìœ„ ê°œë³„ ì €ì¥ â†’ ì ë¦½ ê±´ë‹¹ 1ê°œ ë ˆì½”ë“œë¡œ ê°œì„ 
  - 10,000ì› ì‚¬ìš© ì‹œ: 10,000ê°œ â†’ 1ê°œ ë ˆì½”ë“œ (99.99% ê°ì†Œ)
  - DB INSERT, ë©”ëª¨ë¦¬, ìŠ¤í† ë¦¬ì§€ ë¹„ìš© ëŒ€í­ ì ˆê°
- ì ë¦½ ê±´ ì €ì¥ì€ `saveAll()`ì„ í†µí•œ ë°°ì¹˜ ì²˜ë¦¬ë¡œ ì„±ëŠ¥ í–¥ìƒ
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ìŠ¤íƒ€ì¼(`fold`)ì„ í™œìš©í•œ ë¶ˆë³€ì„± ìœ ì§€
- JPA ë°°ì¹˜ ì„¤ì •ì„ í†µí•œ ë„¤íŠ¸ì›Œí¬ ì™•ë³µ íšŸìˆ˜ ê°ì†Œ

#### 4.1.2 ì‚¬ìš© ìš°ì„ ìˆœìœ„ ì•Œê³ ë¦¬ì¦˜

```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    
    fun selectAccumulationsForUsage(
        memberId: Long,
        usageAmount: Money,
        accumulations: List<PointAccumulation>
    ): List<PointAccumulation> {
        
        // 1. ì‚¬ìš© ê°€ëŠ¥í•œ ì ë¦½ ê±´ë§Œ í•„í„°ë§
        val available = accumulations
            .filter { it.hasAvailableAmount() }
            .filter { !it.isExpired() }
        
        // 2. ìš°ì„ ìˆœìœ„ ì •ë ¬
        // 1ìˆœìœ„: ìˆ˜ê¸° ì§€ê¸‰ í¬ì¸íŠ¸ (ë‚´ë¦¼ì°¨ìˆœ)
        // 2ìˆœìœ„: ë§Œë£Œì¼ì´ ì§§ì€ ìˆœ (ì˜¤ë¦„ì°¨ìˆœ)
        val sorted = available.sortedWith(
            compareByDescending<PointAccumulation> { it.isManualGrant() }
                .thenBy { it.expirationDate }
        )
        
        // 3. ì‚¬ìš©í•  ì ë¦½ ê±´ ì„ íƒ
        return selectAccumulations(sorted, usageAmount)
    }
    
    private fun selectAccumulations(
        accumulations: List<PointAccumulation>,
        usageAmount: Money
    ): List<PointAccumulation> {
        
        val selected = mutableListOf<PointAccumulation>()
        var remaining = usageAmount
        
        for (accumulation in accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val available = accumulation.availableAmount
            val useAmount = if (remaining.isLessThan(available)) {
                remaining
            } else {
                available
            }
            
            selected.add(accumulation)
            remaining = remaining.subtract(useAmount)
        }
        
        // ì‚¬ìš©í•  í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•œ ê²½ìš° ì˜ˆì™¸ ë°œìƒ
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw InsufficientPointException(
                "ì‚¬ìš© ê°€ëŠ¥í•œ í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ë¶€ì¡±í•œ ê¸ˆì•¡: ${remaining.toLong()}ì›")
        }
        
        return selected
    }
}
```

**ìš°ì„ ìˆœìœ„ ê·œì¹™**:
1. **ìˆ˜ê¸° ì§€ê¸‰ í¬ì¸íŠ¸ ìš°ì„ **: `isManualGrant = true`ì¸ í¬ì¸íŠ¸ê°€ ë¨¼ì € ì‚¬ìš©ë¨
2. **ë§Œë£Œì¼ ì§§ì€ ìˆœ**: ë§Œë£Œì¼ì´ ê°€ê¹Œìš´ í¬ì¸íŠ¸ê°€ ë¨¼ì € ì‚¬ìš©ë¨ (FIFO)

## 5. í¬ì¸íŠ¸ ì·¨ì†Œ ì„œë¹„ìŠ¤

### 5.1 PointCancellationService

#### 5.1.1 ì‚¬ìš© ì·¨ì†Œ ì²˜ë¦¬ ë¡œì§

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointCancellationUseCase
import com.musinsa.payments.point.application.port.output.PointKeyGenerator
import com.musinsa.payments.point.application.port.output.config.PointConfigPort
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsageDetailPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsagePersistencePort

@Transactional
@Service
class PointCancellationService(
    private val pointUsagePersistencePort: PointUsagePersistencePort,
    private val pointUsageDetailPersistencePort: PointUsageDetailPersistencePort,
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointKeyGenerator: PointKeyGenerator,
    private val pointConfigPort: PointConfigPort
) : PointCancellationUseCase {
    
    override fun cancelUsage(
        pointKey: String, 
        amount: Long?,
        reason: String?
    ): PointUsage {
        // 1. ì‚¬ìš© ê±´ ì¡°íšŒ
        val usage = pointUsagePersistencePort
            .findByPointKey(pointKey)
            .orElseThrow { IllegalArgumentException("í¬ì¸íŠ¸ ì‚¬ìš© ê±´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $pointKey") }
        
        // 2. ì·¨ì†Œ ê¸ˆì•¡ ê²°ì • (nullì´ë©´ ì „ì²´ ì·¨ì†Œ)
        val cancelAmount = if (amount != null) {
            Money.of(amount)
        } else {
            usage.getRemainingAmount()
        }
        
        // 3. ì·¨ì†Œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        if (!usage.canCancel(cancelAmount)) {
            throw CannotCancelUsageException()
        }
        
        // 4. ì‚¬ìš© ìƒì„¸ ë‚´ì—­ ì¡°íšŒ
        val usageDetails = pointUsageDetailPersistencePort.findByUsagePointKey(pointKey)
        
        // 5. ìƒì„¸ ë‚´ì—­ë³„ë¡œ ì·¨ì†Œ ì²˜ë¦¬ ë° ì ë¦½ ê±´ ë³µì›
        var remainingCancelAmount = cancelAmount
        val restoredAccumulations = mutableMapOf<Long, Money>()
        
        for (detail in usageDetails) {
            if (remainingCancelAmount.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val detailRemaining = detail.getRemainingAmount()
            if (detailRemaining.isLessThanOrEqual(Money.ZERO)) {
                continue
            }
            
            val detailCancelAmount = if (remainingCancelAmount.isLessThan(detailRemaining)) {
                remainingCancelAmount
            } else {
                detailRemaining
            }
            
            // ìƒì„¸ ë‚´ì—­ ì·¨ì†Œ ì²˜ë¦¬
            detail.cancel(detailCancelAmount)
            
            // ì ë¦½ ê±´ ë³µì› ê¸ˆì•¡ ëˆ„ì 
            val accumulationId = detail.pointAccumulationId
            val currentRestoreAmount = restoredAccumulations.getOrDefault(accumulationId, Money.ZERO)
            restoredAccumulations[accumulationId] = currentRestoreAmount.add(detailCancelAmount)
            
            remainingCancelAmount = remainingCancelAmount.subtract(detailCancelAmount)
        }
        
        // 6. ì ë¦½ ê±´ ë³µì› ì²˜ë¦¬ (ë§Œë£Œ í¬ì¸íŠ¸ í™•ì¸ ë° ì‹ ê·œ ì ë¦½ ì²˜ë¦¬)
        for ((accumulationId, restoreAmount) in restoredAccumulations) {
            restoreAccumulation(accumulationId, restoreAmount)
        }
        
        // 7. ì‚¬ìš© ê±´ ì·¨ì†Œ ì²˜ë¦¬ ë° ì €ì¥
        usage.cancel(cancelAmount)
        val savedUsage = pointUsagePersistencePort.save(usage)
        pointUsageDetailPersistencePort.saveAll(usageDetails)
        
        return savedUsage
    }
    
    /**
     * ì ë¦½ ê±´ ë³µì› ì²˜ë¦¬
     * ë§Œë£Œëœ í¬ì¸íŠ¸ì¸ ê²½ìš° ì‹ ê·œ ì ë¦½ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ , ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ê¸°ì¡´ ì ë¦½ ê±´ ë³µì›
     */
    private fun restoreAccumulation(accumulationId: Long, restoreAmount: Money) {
        // ì ë¦½ ê±´ ì¡°íšŒ
        val accumulation = pointAccumulationPersistencePort
            .findById(accumulationId)
            .orElseThrow { IllegalArgumentException("í¬ì¸íŠ¸ ì ë¦½ ê±´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $accumulationId") }
        
        // ë§Œë£Œ ì—¬ë¶€ í™•ì¸
        if (accumulation.isExpired()) {
            // ë§Œë£Œëœ í¬ì¸íŠ¸ëŠ” ì‹ ê·œ ì ë¦½ìœ¼ë¡œ ì²˜ë¦¬
            val newAccumulation = createNewAccumulationForExpiredPoint(
                memberId = accumulation.memberId,
                amount = restoreAmount,
                originalExpirationDate = accumulation.expirationDate
            )
            pointAccumulationPersistencePort.save(newAccumulation)
        } else {
            // ë§Œë£Œë˜ì§€ ì•Šì€ í¬ì¸íŠ¸ëŠ” ê¸°ì¡´ ì ë¦½ ê±´ ë³µì›
            accumulation.restore(restoreAmount)
            pointAccumulationPersistencePort.save(accumulation)
        }
    }
    
    /**
     * ë§Œë£Œ í¬ì¸íŠ¸ í™•ì¸ ë° ì‹ ê·œ ì ë¦½ ì²˜ë¦¬
     */
    private fun createNewAccumulationForExpiredPoint(
        memberId: Long,
        amount: Money,
        originalExpirationDate: LocalDate
    ): PointAccumulation {
        // ë§Œë£Œì¼ì´ ì§€ë‚¬ëŠ”ì§€ í™•ì¸
        val today = LocalDate.now()
        require(today.isAfter(originalExpirationDate)) { "ë§Œë£Œë˜ì§€ ì•Šì€ í¬ì¸íŠ¸ì…ë‹ˆë‹¤." }
        
        // ë§Œë£Œëœ í¬ì¸íŠ¸ëŠ” ì‹ ê·œ ì ë¦½ìœ¼ë¡œ ì²˜ë¦¬
        val defaultExpirationDays = getConfigIntValue("DEFAULT_EXPIRATION_DAYS")
        val newExpirationDate = today.plusDays(defaultExpirationDays.toLong())
        
        val pointKey = pointKeyGenerator.generate().value
        
        return PointAccumulation(
            pointKey = pointKey,
            memberId = memberId,
            amount = amount,
            expirationDate = newExpirationDate,
            isManualGrant = false
        )
    }
    
    /**
     * ì„¤ì • ê°’ì„ Int íƒ€ì…ìœ¼ë¡œ ì¡°íšŒ
     */
    private fun getConfigIntValue(configKey: String): Int {
        return pointConfigPort.findByConfigKey(configKey)
            .orElseThrow { IllegalArgumentException("ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $configKey") }
            .getIntValue()
    }
}
```

**ì£¼ìš” ì±…ì„**:
- ì‚¬ìš© ê±´ ì¡°íšŒ ë° ê²€ì¦
- ì‚¬ìš© ìƒì„¸ ë‚´ì—­ ì·¨ì†Œ ì²˜ë¦¬
- ë§Œë£Œëœ í¬ì¸íŠ¸ëŠ” ì‹ ê·œ ì ë¦½ ì²˜ë¦¬
- ë§Œë£Œë˜ì§€ ì•Šì€ í¬ì¸íŠ¸ëŠ” ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ ë³µì›

#### 5.1.2 ë§Œë£Œ í¬ì¸íŠ¸ ì²˜ë¦¬ ë¡œì§

ë§Œë£Œëœ í¬ì¸íŠ¸ë¥¼ ì‚¬ìš© ì·¨ì†Œí•  ë•ŒëŠ” ë‹¤ìŒ ë¡œì§ì„ ë”°ë¦…ë‹ˆë‹¤:

1. **ë§Œë£Œ í™•ì¸**: ì‚¬ìš© ì·¨ì†Œ ì‹œì ì— í•´ë‹¹ ì ë¦½ ê±´ì´ ë§Œë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
2. **ì‹ ê·œ ì ë¦½**: ë§Œë£Œëœ í¬ì¸íŠ¸ëŠ” ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ì„ ë³µì›í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ì‹ ê·œ ì ë¦½ìœ¼ë¡œ ì²˜ë¦¬
3. **ë§Œë£Œì¼ ì„¤ì •**: ì‹ ê·œ ì ë¦½ì˜ ë§Œë£Œì¼ì€ ê¸°ë³¸ ë§Œë£Œì¼ë¡œ ì„¤ì •

## 6. í¬ì¸íŠ¸ ì¡°íšŒ ì„œë¹„ìŠ¤

### 6.1 PointQueryService

#### 6.1.1 ì”ì•¡ ì¡°íšŒ ì „ëµ (í•˜ì´ë¸Œë¦¬ë“œ)

| ì¡°íšŒ ë°©ì‹ | ì‚¬ìš© ì‹œì  | íŠ¹ì§• |
|----------|----------|------|
| **MemberPointBalance ìºì‹œ** | ì¼ë°˜ ì”ì•¡ ì¡°íšŒ | O(1) ë¹ ë¥¸ ì¡°íšŒ, ë¹„ë™ê¸° ì—…ë°ì´íŠ¸ |
| **SUM ì¿¼ë¦¬ (Fallback)** | ìºì‹œ ì—†ëŠ” ê²½ìš° | ì •í™•í•œ ê³„ì‚°, ì ë¦½ ê±´ ì§ì ‘ í•©ì‚° |

```kotlin
package com.musinsa.payments.point.application.service

import com.musinsa.payments.point.application.port.input.PointQueryUseCase
import com.musinsa.payments.point.application.port.input.PointBalanceResult
import com.musinsa.payments.point.application.port.output.persistence.PointAccumulationPersistencePort
import com.musinsa.payments.point.application.port.output.persistence.PointUsagePersistencePort
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable

@Transactional(readOnly = true)
@Service
class PointQueryService(
    private val pointAccumulationPersistencePort: PointAccumulationPersistencePort,
    private val pointUsagePersistencePort: PointUsagePersistencePort,
    private val memberPointBalancePersistencePort: MemberPointBalancePersistencePort  // ìºì‹œ ì¡°íšŒìš©
) : PointQueryUseCase {
    
    override fun getBalance(memberId: Long): PointBalanceResult {
        // 1. ì ë¦½ ë‚´ì—­ ì¡°íšŒ (ACCUMULATED ìƒíƒœë§Œ)
        val allAccumulations = pointAccumulationPersistencePort
            .findByMemberIdAndStatus(memberId, PointAccumulationStatus.ACCUMULATED)
        
        // 2. ì´ ì”ì•¡ ê³„ì‚° (ëª¨ë“  ì ë¦½ ê¸ˆì•¡ í•©ê³„)
        val totalBalance = allAccumulations
            .sumOf { it.amount.toLong() }
        
        // 3. ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ ê³„ì‚° (ì‚¬ìš© ê°€ëŠ¥í•œ ì ë¦½ ê±´ì˜ ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ í•©ê³„)
        val availableBalance = allAccumulations
            .filter { !it.isExpired() }
            .sumOf { it.availableAmount.toLong() }
        
        // 4. ë§Œë£Œ ì”ì•¡ ê³„ì‚° (ë§Œë£Œëœ ì ë¦½ ê±´ì˜ ì‚¬ìš© ê°€ëŠ¥ ì”ì•¡ í•©ê³„)
        val expiredBalance = allAccumulations
            .filter { it.isExpired() }
            .sumOf { it.availableAmount.toLong() }
        
        return PointBalanceResult(
            memberId = memberId,
            totalBalance = totalBalance,
            availableBalance = availableBalance,
            expiredBalance = expiredBalance,
            accumulations = allAccumulations
        )
    }
    
    override fun getUsageHistory(
        memberId: Long, 
        orderNumber: String?,
        pageable: Pageable
    ): Page<PointUsage> {
        return pointUsagePersistencePort.findUsageHistoryByMemberId(
            memberId = memberId,
            orderNumber = orderNumber,
            pageable = pageable
        )
    }
}
```

## 7. íŠ¸ëœì­ì…˜ ê²½ê³„

### 7.1 íŠ¸ëœì­ì…˜ ì „ëµ

- **ì„œë¹„ìŠ¤ ë©”ì„œë“œ ë ˆë²¨**: `@Transactional` ì–´ë…¸í…Œì´ì…˜ ì‚¬ìš©
- **ì½ê¸° ì „ìš©**: `@Transactional(readOnly = true)` ì‚¬ìš©
- **íŠ¸ëœì­ì…˜ ì „íŒŒ**: ê¸°ë³¸ê°’(REQUIRED) ì‚¬ìš©

### 7.2 íŠ¸ëœì­ì…˜ ë²”ìœ„

- **ì ë¦½**: ì ë¦½ ê±´ ì €ì¥, ì„¤ì • ì¡°íšŒ
- **ì ë¦½ ì·¨ì†Œ**: ì ë¦½ ê±´ ì—…ë°ì´íŠ¸, ì·¨ì†Œ ì´ë ¥ ì €ì¥
- **ì‚¬ìš©**: ì‚¬ìš© ê±´ ì €ì¥, ìƒì„¸ ë‚´ì—­ ì €ì¥, ì ë¦½ ê±´ ì¼ê´„ ì €ì¥ (ë°°ì¹˜ ì²˜ë¦¬)
- **ì‚¬ìš© ì·¨ì†Œ**: ì‚¬ìš© ê±´ ì—…ë°ì´íŠ¸, ìƒì„¸ ë‚´ì—­ ì—…ë°ì´íŠ¸, ì ë¦½ ê±´ ì—…ë°ì´íŠ¸/ìƒì„±, ì·¨ì†Œ ì´ë ¥ ì €ì¥

## 8. ë™ì‹œì„± ì œì–´ ì „ëµ

### 8.1 ë™ì‹œì„± ì´ìŠˆ ì‹œë‚˜ë¦¬ì˜¤

- **ë™ì¼ ì‚¬ìš©ì ë™ì‹œ í¬ì¸íŠ¸ ì‚¬ìš©**: ì—¬ëŸ¬ ìš”ì²­ì´ ë™ì‹œì— ê°™ì€ ì ë¦½ ê±´ì„ ì‚¬ìš©í•˜ë ¤ëŠ” ê²½ìš°
- **ì ë¦½ê³¼ ì‚¬ìš©ì˜ ë™ì‹œ ë°œìƒ**: ì ë¦½ ì²˜ë¦¬ ì¤‘ì— í•´ë‹¹ ì ë¦½ ê±´ ì‚¬ìš© ìš”ì²­ì´ ë“¤ì–´ì˜¤ëŠ” ê²½ìš°
- **ì‚¬ìš© ì·¨ì†Œ ë™ì‹œ ìš”ì²­**: ê°™ì€ ì‚¬ìš© ê±´ì— ëŒ€í•´ ë™ì‹œì— ì·¨ì†Œ ìš”ì²­ì´ ë“¤ì–´ì˜¤ëŠ” ê²½ìš°

### 8.2 í•´ê²° ì „ëµ

#### 8.2.1 ë¹„ê´€ì  ë½ (Pessimistic Lock)

```kotlin
interface PointAccumulationPersistencePort {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    fun findByIdWithLock(id: Long): PointAccumulation?

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    fun findAvailableAccumulationsByMemberIdWithLock(memberId: Long): List<PointAccumulation>
}
```

**ì ìš© ì‹œì **:
- í¬ì¸íŠ¸ ì‚¬ìš© ì‹œ ì ë¦½ ê±´ ì¡°íšŒ
- ì‚¬ìš© ì·¨ì†Œ ì‹œ ì ë¦½ ê±´ ë³µì›

#### 8.2.2 íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€

```kotlin
@Transactional(isolation = Isolation.READ_COMMITTED)
class PointUsageService : PointUsageUseCase {
    // ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€ìœ¼ë¡œ ì¶©ë¶„í•œ ê²½ìš°
}

@Transactional(isolation = Isolation.REPEATABLE_READ)
fun useWithHighIsolation(
    memberId: Long,
    orderNumber: String,
    amount: Long
): PointUsage {
    // ë†’ì€ ê²©ë¦¬ ìˆ˜ì¤€ì´ í•„ìš”í•œ ê²½ìš°
}
```

#### 8.2.3 ì‚¬ìš©ìë³„ ë½

```kotlin
@Service
class PointUsageService(
    private val lockService: DistributedLockService
) : PointUsageUseCase {
    override fun use(
        memberId: Long,
        orderNumber: String,
        amount: Long
    ): PointUsage {
        val lockKey = "point:use:member:$memberId"
        return lockService.executeWithLock(lockKey, timeout = 5000) {
            executeUse(memberId, orderNumber, amount)
        }
    }
}
```

### 8.3 ë°ë“œë½ ë°©ì§€

- **ìˆœì„œ ë³´ì¥**: ì ë¦½ ê±´ ì¡°íšŒ ì‹œ í•­ìƒ ID ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë½ íšë“
- **íƒ€ì„ì•„ì›ƒ ì„¤ì •**: ë½ ëŒ€ê¸° ì‹œê°„ ì œí•œ (5ì´ˆ ê¶Œì¥)
- **ë½ ë²”ìœ„ ìµœì†Œí™”**: í•„ìš”í•œ ìµœì†Œ ë²”ìœ„ë§Œ ë½ ì ìš©

## 9. ì˜ˆì™¸ ì²˜ë¦¬ ì „ëµ

### 9.1 ì˜ˆì™¸ ê³„ì¸µ êµ¬ì¡°

```
RuntimeException
â””â”€â”€ PointDomainException
    â”œâ”€â”€ InsufficientPointException
    â”œâ”€â”€ CannotCancelAccumulationException
    â”œâ”€â”€ CannotCancelUsageException
    â”œâ”€â”€ InvalidAmountException
    â”œâ”€â”€ ExceededMaxBalanceException
    â””â”€â”€ ...
```

### 8.2 ì˜ˆì™¸ ì²˜ë¦¬ íë¦„

1. **ë„ë©”ì¸ ì˜ˆì™¸ ë°œìƒ**: ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ìœ„ë°˜ ì‹œ ë„ë©”ì¸ ì˜ˆì™¸ ë°œìƒ
2. **ì„œë¹„ìŠ¤ ë ˆì´ì–´**: ë„ë©”ì¸ ì˜ˆì™¸ë¥¼ ê·¸ëŒ€ë¡œ ì „íŒŒ
3. **ì»¨íŠ¸ë¡¤ëŸ¬ ë ˆì´ì–´**: ì˜ˆì™¸ë¥¼ HTTP ì‘ë‹µìœ¼ë¡œ ë³€í™˜

## 9. ë‹¤ìŒ ë‹¨ê³„

ë‹¤ìŒ ë‹¨ê³„ì—ì„œëŠ” ì„¤ì • ê´€ë¦¬ ì„¤ê³„ë¥¼ í†µí•´ ë™ì  ì„¤ì • ê´€ë¦¬ ë°©ë²•ì„ êµ¬ì²´í™”í•  ì˜ˆì •ì…ë‹ˆë‹¤.

---

**ë‹¤ìŒ ë¬¸ì„œ**: [06. ì„¤ì • ê´€ë¦¬ ì„¤ê³„](./06-ì„¤ì •-ê´€ë¦¬-ì„¤ê³„.md)

