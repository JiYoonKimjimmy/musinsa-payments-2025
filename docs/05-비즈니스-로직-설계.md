# 05. 비즈니스 로직 설계

## 1. 개요

포인트 시스템의 핵심 비즈니스 로직을 설계합니다. 적립, 적립 취소, 사용, 사용 취소의 각 기능별로 서비스 레이어를 구성합니다.

## 2. 서비스 레이어 구조

### 2.1 패키지 구조

```
com.musinsa.payments.point.service
├── PointAccumulationService      # 적립 서비스
├── PointUsageService             # 사용 서비스
├── PointCancellationService      # 취소 서비스
└── PointQueryService             # 조회 서비스
```

## 3. 포인트 적립 서비스

### 3.1 PointAccumulationService

#### 3.1.1 적립 처리 로직

```kotlin
package com.musinsa.payments.point.service

@Transactional
class PointAccumulationService(
    private val accumulationRepository: PointAccumulationRepository,
    private val configRepository: PointConfigRepository,
    private val domainService: PointAccumulationDomainService,
    private val pointKeyGenerator: PointKeyGenerator
) {
    
    fun accumulate(request: AccumulatePointRequest): AccumulatePointResponse {
        // 1. 설정 조회
        val maxAmountConfig = configRepository
            .findByConfigKey("MAX_ACCUMULATION_AMOUNT_PER_TIME")
            ?: throw ConfigNotFoundException()
        
        val maxBalanceConfig = configRepository
            .findByConfigKey("MAX_BALANCE_PER_MEMBER")
            ?: throw ConfigNotFoundException()
        
        val defaultExpirationDaysConfig = configRepository
            .findByConfigKey("DEFAULT_EXPIRATION_DAYS")
            ?: throw ConfigNotFoundException()
        
        // 2. 요청 데이터 검증
        val amount = Money.of(request.amount)
        validateAmount(amount, maxAmountConfig.getLongValue())
        
        // 3. 현재 잔액 확인
        val currentBalance = accumulationRepository
            .calculateTotalBalance(request.memberId)
        validateMaxBalance(currentBalance, amount, maxBalanceConfig.getLongValue())
        
        // 4. 만료일 계산
        val expirationDays = request.expirationDays 
            ?: defaultExpirationDaysConfig.getIntValue()
        val expirationDate = calculateExpirationDate(expirationDays)
        
        // 5. 포인트 적립 생성
        val accumulation = domainService.createAccumulation(
            request.memberId,
            amount,
            expirationDate,
            request.isManualGrant ?: false,
            pointKeyGenerator
        )
        
        // 6. 저장
        val saved = accumulationRepository.save(accumulation)
        
        // 7. 응답 생성
        return AccumulatePointResponse.from(saved)
    }
    
    private fun validateAmount(amount: Money, maxAmount: Long) {
        if (amount.isLessThan(Money.of(1))) {
            throw InvalidAmountException("적립 금액은 1원 이상이어야 합니다.")
        }
        if (amount.isGreaterThan(Money.of(maxAmount))) {
            throw ExceededMaxAccumulationException(
                "1회 최대 적립 금액(${maxAmount}원)을 초과했습니다.")
        }
    }
    
    private fun validateMaxBalance(
        currentBalance: Money, 
        newAmount: Money, 
        maxBalance: Long
    ) {
        val totalBalance = currentBalance.add(newAmount)
        if (totalBalance.isGreaterThan(Money.of(maxBalance))) {
            throw ExceededMaxBalanceException(
                "개인별 최대 보유 금액(${maxBalance}원)을 초과했습니다.")
        }
    }
    
    private fun calculateExpirationDate(expirationDays: Int): LocalDate {
        val now = LocalDate.now()
        val expirationDate = now.plusDays(expirationDays.toLong())
        
        // 만료일 범위 검증
        val minDaysConfig = configRepository
            .findByConfigKey("MIN_EXPIRATION_DAYS")
            ?: throw ConfigNotFoundException()
        val maxDaysConfig = configRepository
            .findByConfigKey("MAX_EXPIRATION_DAYS")
            ?: throw ConfigNotFoundException()
        
        if (expirationDays < minDaysConfig.getIntValue() 
            || expirationDays >= maxDaysConfig.getIntValue()) {
            throw InvalidExpirationDateException(
                "만료일은 ${minDaysConfig.getIntValue()}일 이상 ${maxDaysConfig.getIntValue()}일 미만이어야 합니다.")
        }
        
        return expirationDate
    }
}
```

**주요 책임**:
- 적립 요청 검증
- 설정 조회 및 적용
- 잔액 확인 및 검증
- 포인트 적립 생성 및 저장

#### 3.1.2 적립 취소 처리 로직

```kotlin
@Transactional
class PointAccumulationService {
    
    fun cancelAccumulation(
        pointKey: String, 
        request: CancelAccumulationRequest
    ): CancelAccumulationResponse {
        
        // 1. 적립 건 조회
        val accumulation = accumulationRepository
            .findByPointKey(pointKey)
            ?: throw AccumulationNotFoundException()
        
        // 2. 취소 가능 여부 확인
        if (!accumulation.canBeCancelled()) {
            throw CannotCancelAccumulationException()
        }
        
        // 3. 적립 취소 처리
        accumulation.cancel()
        accumulationRepository.save(accumulation)
        
        // 4. 취소 이력 기록
        val cancellation = PointCancellation().apply {
            this.pointKey = pointKeyGenerator.generate().value
            this.cancellationType = CancellationType.ACCUMULATION_CANCELLATION
            this.targetPointKey = pointKey
            this.memberId = accumulation.memberId
            this.amount = accumulation.amount
            this.reason = request.reason
        }
        
        cancellationRepository.save(cancellation)
        
        // 5. 응답 생성
        return CancelAccumulationResponse.from(cancellation)
    }
}
```

**주요 책임**:
- 적립 건 조회 및 검증
- 취소 가능 여부 확인
- 적립 취소 처리
- 취소 이력 기록

## 4. 포인트 사용 서비스

### 4.1 PointUsageService

#### 4.1.1 사용 처리 로직

```kotlin
package com.musinsa.payments.point.service

@Transactional
class PointUsageService(
    private val accumulationRepository: PointAccumulationRepository,
    private val usageRepository: PointUsageRepository,
    private val detailRepository: PointUsageDetailRepository,
    private val priorityService: PointUsagePriorityService,
    private val pointKeyGenerator: PointKeyGenerator
) {
    
    fun use(request: UsePointRequest): UsePointResponse {
        // 1. 사용 가능한 적립 건 조회
        val accumulations = accumulationRepository
            .findAvailableByMemberId(request.memberId)
        
        // 2. 사용할 적립 건 선택 (우선순위 적용)
        val usageAmount = Money.of(request.amount)
        val selectedAccumulations = priorityService
            .selectAccumulationsForUsage(
                request.memberId,
                usageAmount,
                accumulations
            )
        
        // 3. 포인트 사용 생성
        val usage = PointUsage().apply {
            this.pointKey = pointKeyGenerator.generate().value
            this.memberId = request.memberId
            this.orderNumber = OrderNumber.of(request.orderNumber)
            this.totalAmount = usageAmount
            this.cancelledAmount = Money.ZERO
            this.status = PointUsageStatus.USED
        }
        
        val savedUsage = usageRepository.save(usage)
        
        // 4. 사용 상세 내역 생성 및 저장
        val details = createUsageDetails(
            savedUsage,
            selectedAccumulations,
            usageAmount
        )
        detailRepository.saveAll(details)
        
        // 5. 적립 건의 사용 가능 잔액 차감
        updateAccumulationAvailableAmounts(selectedAccumulations, details)
        selectedAccumulations.forEach { accumulationRepository.save(it) }
        
        // 6. 응답 생성
        return UsePointResponse.from(savedUsage, details)
    }
    
    private fun createUsageDetails(
        usage: PointUsage,
        accumulations: List<PointAccumulation>,
        totalUsageAmount: Money
    ): List<PointUsageDetail> {
        
        val details = mutableListOf<PointUsageDetail>()
        var remaining = totalUsageAmount
        
        for (accumulation in accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val available = accumulation.availableAmount
            val useAmount = if (remaining.isLessThan(available)) {
                remaining
            } else {
                available
            }
            
            val detail = PointUsageDetail().apply {
                this.pointUsageId = usage.id
                this.pointAccumulationId = accumulation.id
                this.amount = useAmount
                this.cancelledAmount = Money.ZERO
            }
            
            details.add(detail)
            remaining = remaining.subtract(useAmount)
        }
        
        return details
    }
    
    private fun updateAccumulationAvailableAmounts(
        accumulations: List<PointAccumulation>,
        details: List<PointUsageDetail>
    ) {
        val usageAmountMap = details
            .groupBy { it.pointAccumulationId }
            .mapValues { (_, detailList) ->
                detailList.fold(Money.ZERO) { acc, detail ->
                    acc.add(detail.amount)
                }
            }
        
        for (accumulation in accumulations) {
            val usageAmount = usageAmountMap[accumulation.id] ?: Money.ZERO
            accumulation.use(usageAmount)
        }
    }
}
```

**주요 책임**:
- 사용 가능한 적립 건 조회
- 우선순위에 따른 적립 건 선택
- 포인트 사용 및 상세 내역 생성
- 적립 건의 사용 가능 잔액 업데이트

#### 4.1.2 사용 우선순위 알고리즘

```kotlin
package com.musinsa.payments.point.domain.service

class PointUsagePriorityService {
    
    fun selectAccumulationsForUsage(
        memberId: Long,
        usageAmount: Money,
        accumulations: List<PointAccumulation>
    ): List<PointAccumulation> {
        
        // 1. 사용 가능한 적립 건만 필터링
        val available = accumulations
            .filter { it.hasAvailableAmount() }
            .filter { !it.isExpired() }
        
        // 2. 우선순위 정렬
        // 1순위: 수기 지급 포인트 (내림차순)
        // 2순위: 만료일이 짧은 순 (오름차순)
        val sorted = available.sortedWith(
            compareByDescending<PointAccumulation> { it.isManualGrant() }
                .thenBy { it.expirationDate }
        )
        
        // 3. 사용할 적립 건 선택
        return selectAccumulations(sorted, usageAmount)
    }
    
    private fun selectAccumulations(
        accumulations: List<PointAccumulation>,
        usageAmount: Money
    ): List<PointAccumulation> {
        
        val selected = mutableListOf<PointAccumulation>()
        var remaining = usageAmount
        
        for (accumulation in accumulations) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val available = accumulation.availableAmount
            val useAmount = if (remaining.isLessThan(available)) {
                remaining
            } else {
                available
            }
            
            selected.add(accumulation)
            remaining = remaining.subtract(useAmount)
        }
        
        // 사용할 포인트가 부족한 경우 예외 발생
        if (remaining.isGreaterThan(Money.ZERO)) {
            throw InsufficientPointException(
                "사용 가능한 포인트가 부족합니다. 부족한 금액: ${remaining.toLong()}원")
        }
        
        return selected
    }
}
```

**우선순위 규칙**:
1. **수기 지급 포인트 우선**: `isManualGrant = true`인 포인트가 먼저 사용됨
2. **만료일 짧은 순**: 만료일이 가까운 포인트가 먼저 사용됨 (FIFO)

## 5. 포인트 취소 서비스

### 5.1 PointCancellationService

#### 5.1.1 사용 취소 처리 로직

```kotlin
package com.musinsa.payments.point.service

@Transactional
class PointCancellationService(
    private val usageRepository: PointUsageRepository,
    private val detailRepository: PointUsageDetailRepository,
    private val accumulationRepository: PointAccumulationRepository,
    private val accumulationService: PointAccumulationService,
    private val pointKeyGenerator: PointKeyGenerator,
    private val cancellationRepository: PointCancellationRepository,
    private val configRepository: PointConfigRepository,
    private val domainService: PointAccumulationDomainService
) {
    
    fun cancelUsage(
        pointKey: String, 
        request: CancelUsageRequest
    ): CancelUsageResponse {
        
        // 1. 사용 건 조회
        val usage = usageRepository
            .findByPointKey(pointKey)
            ?: throw UsageNotFoundException()
        
        // 2. 취소 금액 결정
        val cancelAmount = request.amount?.let { Money.of(it) }
            ?: usage.getRemainingAmount()
        
        // 3. 취소 가능 여부 확인
        if (!usage.canCancel(cancelAmount)) {
            throw CannotCancelUsageException()
        }
        
        // 4. 사용 상세 내역 조회
        val details = detailRepository
            .findByPointUsageId(usage.id ?: throw IllegalStateException("Usage ID is null"))
        
        // 5. 사용 취소 처리
        usage.cancel(cancelAmount)
        usageRepository.save(usage)
        
        // 6. 상세 내역 취소 처리 및 적립 건 복원
        val newAccumulations = processUsageDetailsCancellation(
            details,
            cancelAmount,
            usage.memberId ?: throw IllegalStateException("Member ID is null")
        )
        
        // 7. 취소 이력 기록
        val cancellation = PointCancellation().apply {
            this.pointKey = pointKeyGenerator.generate().value
            this.cancellationType = CancellationType.USAGE_CANCELLATION
            this.targetPointKey = pointKey
            this.memberId = usage.memberId
            this.amount = cancelAmount
            this.reason = request.reason
        }
        
        cancellationRepository.save(cancellation)
        
        // 8. 응답 생성
        return CancelUsageResponse.from(cancellation, newAccumulations)
    }
    
    private fun processUsageDetailsCancellation(
        details: List<PointUsageDetail>,
        cancelAmount: Money,
        memberId: Long
    ): List<NewAccumulationInfo> {
        
        val newAccumulations = mutableListOf<NewAccumulationInfo>()
        var remaining = cancelAmount
        
        // 역순으로 처리 (나중에 사용한 것부터 취소)
        val reversedDetails = details.reversed()
        
        for (detail in reversedDetails) {
            if (remaining.isLessThanOrEqual(Money.ZERO)) {
                break
            }
            
            val detailRemaining = detail.getRemainingAmount()
            val cancelDetailAmount = if (remaining.isLessThan(detailRemaining)) {
                remaining
            } else {
                detailRemaining
            }
            
            // 상세 내역 취소 처리
            detail.cancel(cancelDetailAmount)
            detailRepository.save(detail)
            
            // 적립 건 조회
            val accumulation = accumulationRepository
                .findById(detail.pointAccumulationId)
                ?: throw AccumulationNotFoundException()
            
            // 만료 여부 확인
            val now = LocalDate.now()
            if (accumulation.isExpiredAt(now)) {
                // 만료된 포인트는 신규 적립 처리
                val newAccumulation = createNewAccumulationForExpired(
                    memberId,
                    cancelDetailAmount,
                    accumulation
                )
                val saved = accumulationRepository.save(newAccumulation)
                newAccumulations.add(NewAccumulationInfo.from(saved))
            } else {
                // 만료되지 않은 포인트는 사용 가능 잔액 복원
                accumulation.restore(cancelDetailAmount)
                accumulationRepository.save(accumulation)
            }
            
            remaining = remaining.subtract(cancelDetailAmount)
        }
        
        return newAccumulations
    }
    
    private fun createNewAccumulationForExpired(
        memberId: Long,
        amount: Money,
        originalAccumulation: PointAccumulation
    ): PointAccumulation {
        
        // 기본 만료일 조회
        val defaultExpirationDaysConfig = configRepository
            .findByConfigKey("DEFAULT_EXPIRATION_DAYS")
            ?: throw ConfigNotFoundException()
        
        val expirationDate = LocalDate.now()
            .plusDays(defaultExpirationDaysConfig.getIntValue().toLong())
        
        return domainService.createAccumulation(
            memberId,
            amount,
            expirationDate,
            false,  // 만료 포인트로 인한 신규 적립은 수기 지급 아님
            pointKeyGenerator
        )
    }
}
```

**주요 책임**:
- 사용 건 조회 및 검증
- 사용 상세 내역 취소 처리
- 만료된 포인트는 신규 적립 처리
- 만료되지 않은 포인트는 사용 가능 잔액 복원

#### 5.1.2 만료 포인트 처리 로직

만료된 포인트를 사용 취소할 때는 다음 로직을 따릅니다:

1. **만료 확인**: 사용 취소 시점에 해당 적립 건이 만료되었는지 확인
2. **신규 적립**: 만료된 포인트는 사용 가능 잔액을 복원할 수 없으므로, 신규 적립으로 처리
3. **만료일 설정**: 신규 적립의 만료일은 기본 만료일로 설정

## 6. 포인트 조회 서비스

### 6.1 PointQueryService

```kotlin
package com.musinsa.payments.point.service

@Transactional(readOnly = true)
class PointQueryService(
    private val accumulationRepository: PointAccumulationRepository,
    private val usageRepository: PointUsageRepository,
    private val detailRepository: PointUsageDetailRepository
) {
    
    fun getBalance(memberId: Long): PointBalanceResponse {
        // 1. 적립 건 조회
        val accumulations = accumulationRepository
            .findByMemberId(memberId)
        
        // 2. 잔액 계산
        val totalBalance = accumulationRepository
            .calculateTotalBalance(memberId)
        val availableBalance = accumulationRepository
            .calculateAvailableBalance(memberId)
        
        // 3. 만료된 포인트 금액 계산
        val expiredBalance = accumulations
            .filter { it.isExpired() }
            .mapNotNull { it.amount }
            .fold(Money.ZERO) { acc, amount -> acc.add(amount) }
        
        // 4. 응답 생성
        return PointBalanceResponse(
            memberId = memberId,
            totalBalance = totalBalance.toLong(),
            availableBalance = availableBalance.toLong(),
            expiredBalance = expiredBalance.toLong(),
            accumulations = accumulations.map { AccumulationSummaryResponse.from(it) }
        )
    }
    
    fun getHistory(
        memberId: Long, 
        orderNumber: String?,
        pageable: Pageable
    ): PointHistoryResponse {
        
        // 1. 사용 건 조회
        val usages = if (orderNumber != null) {
            usageRepository.findByOrderNumber(orderNumber)
        } else {
            usageRepository.findByMemberId(memberId)
        }
        
        // 2. 페이징 처리
        val start = pageable.offset.toInt()
        val end = minOf(start + pageable.pageSize, usages.size)
        val pagedUsages = usages.subList(start, end)
        
        // 3. 사용 상세 내역 조회
        val history = pagedUsages.map { usage ->
            val details = detailRepository
                .findByPointUsageId(usage.id ?: throw IllegalStateException("Usage ID is null"))
            UsageHistoryResponse.from(usage, details)
        }
        
        // 4. 응답 생성
        return PointHistoryResponse(
            content = history,
            page = PageInfo.from(usages.size, pageable)
        )
    }
}
```

## 7. 트랜잭션 경계

### 7.1 트랜잭션 전략

- **서비스 메서드 레벨**: `@Transactional` 어노테이션 사용
- **읽기 전용**: `@Transactional(readOnly = true)` 사용
- **트랜잭션 전파**: 기본값(REQUIRED) 사용

### 7.2 트랜잭션 범위

- **적립**: 적립 건 저장, 설정 조회
- **적립 취소**: 적립 건 업데이트, 취소 이력 저장
- **사용**: 사용 건 저장, 상세 내역 저장, 적립 건 업데이트
- **사용 취소**: 사용 건 업데이트, 상세 내역 업데이트, 적립 건 업데이트/생성, 취소 이력 저장

## 8. 동시성 제어 전략

### 8.1 동시성 이슈 시나리오

- **동일 사용자 동시 포인트 사용**: 여러 요청이 동시에 같은 적립 건을 사용하려는 경우
- **적립과 사용의 동시 발생**: 적립 처리 중에 해당 적립 건 사용 요청이 들어오는 경우
- **사용 취소 동시 요청**: 같은 사용 건에 대해 동시에 취소 요청이 들어오는 경우

### 8.2 해결 전략

#### 8.2.1 비관적 락 (Pessimistic Lock)

```kotlin
interface PointAccumulationRepository {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    fun findByIdWithLock(id: Long): PointAccumulation?

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    fun findAvailableByMemberIdWithLock(memberId: Long): List<PointAccumulation>
}
```

**적용 시점**:
- 포인트 사용 시 적립 건 조회
- 사용 취소 시 적립 건 복원

#### 8.2.2 트랜잭션 격리 수준

```kotlin
@Transactional(isolation = Isolation.READ_COMMITTED)
class PointUsageService {
    // 기본 격리 수준으로 충분한 경우
}

@Transactional(isolation = Isolation.REPEATABLE_READ)
fun useWithHighIsolation(request: UsePointRequest): UsePointResponse {
    // 높은 격리 수준이 필요한 경우
}
```

#### 8.2.3 사용자별 락

```kotlin
@Service
class PointUsageService(
    private val lockService: DistributedLockService
) {
    fun use(request: UsePointRequest): UsePointResponse {
        val lockKey = "point:use:member:${request.memberId}"
        return lockService.executeWithLock(lockKey, timeout = 5000) {
            executeUse(request)
        }
    }
}
```

### 8.3 데드락 방지

- **순서 보장**: 적립 건 조회 시 항상 ID 오름차순으로 정렬하여 락 획득
- **타임아웃 설정**: 락 대기 시간 제한 (5초 권장)
- **락 범위 최소화**: 필요한 최소 범위만 락 적용

## 9. 예외 처리 전략

### 9.1 예외 계층 구조

```
RuntimeException
└── PointDomainException
    ├── InsufficientPointException
    ├── CannotCancelAccumulationException
    ├── CannotCancelUsageException
    ├── InvalidAmountException
    ├── ExceededMaxBalanceException
    └── ...
```

### 8.2 예외 처리 흐름

1. **도메인 예외 발생**: 비즈니스 규칙 위반 시 도메인 예외 발생
2. **서비스 레이어**: 도메인 예외를 그대로 전파
3. **컨트롤러 레이어**: 예외를 HTTP 응답으로 변환

## 9. 다음 단계

다음 단계에서는 설정 관리 설계를 통해 동적 설정 관리 방법을 구체화할 예정입니다.

---

**다음 문서**: [06. 설정 관리 설계](./06-설정-관리-설계.md)

