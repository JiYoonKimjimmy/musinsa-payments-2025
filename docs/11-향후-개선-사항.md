# 11. 향후 개선 사항

## 1. 개요

현재 포인트 시스템은 단일 서버 환경을 기준으로 JPA 비관적 락을 통해 동시성을 제어하고 있습니다.
향후 시스템 확장 및 성능 개선을 위해 고려해야 할 개선 사항들을 정리합니다.

---

## 2. 분산 락 (Distributed Lock) 도입

### 2.1 현재 상황 및 필요성

| 구분   | 현재 상황                           | 한계                   |
|------|---------------------------------|----------------------|
| 환경   | 단일 서버                           | 다중 서버 환경에서 동시성 제어 불가 |
| 락 방식 | JPA 비관적 락 (`SELECT FOR UPDATE`) | DB 락 경합 시 성능 저하      |
| 락 단위 | 행(Row) 단위                       | 논리적 단위(회원별) 락 불가     |

### 2.2 분산 락 도입 시점

- 서버가 2대 이상으로 스케일 아웃될 때
- 포인트 사용 트래픽이 1000 TPS 이상일 때
- 데이터베이스 락 경합으로 인한 성능 저하 발생 시

### 2.3 비관적 락 vs 분산 락

| 구분    | 비관적 락 (현재)   | 분산 락 (개선안)         |
|-------|--------------|--------------------|
| 적용 범위 | 단일 서버        | 다중 서버              |
| 락 저장소 | 데이터베이스       | Redis (인메모리)       |
| 성능    | DB 락 경합 시 느림 | 빠른 락 획득/해제         |
| 복잡도   | 낮음           | 중간 (Redis 인프라 필요)  |
| 락 단위  | 행(Row) 단위    | 논리적 키 단위 (회원 ID 등) |

### 2.4 기술 스택

| 기술                   | 장점              | 단점           |
|----------------------|-----------------|--------------|
| **Redisson** (권장)    | 다양한 락 지원, 자동 갱신 | Redis 인프라 필요 |
| Lettuce + Lua Script | 가볍고 커스터마이징 가능   | 직접 구현 필요     |
| Zookeeper            | 강력한 분산 코디네이션    | 복잡도 높음, 오버스펙 |

### 2.5 락 키 전략

| 기능     | 락 키                                    | 설명           |
|--------|----------------------------------------|--------------|
| 포인트 사용 | `point:use:member:{memberId}`          | 회원별 포인트 사용 락 |
| 포인트 적립 | `point:accumulate:member:{memberId}`   | 회원별 포인트 적립 락 |
| 사용 취소  | `point:cancel:usage:{pointKey}`        | 사용 건별 취소 락   |
| 적립 취소  | `point:cancel:accumulation:{pointKey}` | 적립 건별 취소 락   |

### 2.6 구현 시 고려사항

| 항목         | 설명                                |
|------------|-----------------------------------|
| 락 타임아웃     | waitTime(3-5초), leaseTime(10-30초) |
| 락 해제 실패 대응 | TTL 기반 자동 만료, Watch Dog 자동 갱신     |
| 재시도 전략     | 사용자 요청은 즉시 실패, 백그라운드는 재시도 허용      |
| Redis 장애   | Circuit Breaker 패턴으로 비관적 락 폴백     |
| 데드락 방지     | 락 획득 순서 통일 (ID 오름차순 등)            |
| 모니터링       | 락 획득 성공/실패율, 대기 시간, 보유 시간 메트릭     |

### 2.7 예상 성능 개선

| 지표        | 비관적 락 (현재)     | 분산 락 (개선) | 개선율          |
|-----------|----------------|-----------|--------------|
| 락 획득 시간   | 5-10ms (DB 쿼리) | 1-2ms     | **80% 감소**   |
| 락 해제 시간   | 3-5ms (DB 커밋)  | <1ms      | **90% 감소**   |
| 동시 처리량    | 100 TPS        | 500 TPS   | **400% 증가**  |
| 데이터베이스 부하 | 높음             | 낮음        | **DB 부하 감소** |

### 2.8 도입 로드맵

| Phase           | 기간 | 작업 내용                            |
|-----------------|----|----------------------------------|
| Phase 1: 인프라 구축 | 1주 | Redis 클러스터 구성, Redisson 설정, 모니터링 |
| Phase 2: 개발/테스트 | 2주 | 분산 락 구현, 서비스 적용, 테스트 작성          |
| Phase 3: 성능 테스트 | 1주 | 부하 테스트, 성능 비교, 튜닝                |
| Phase 4: 카나리 배포 | 1주 | 스테이징 검증, 점진적 트래픽 적용 (10→50→100%) |

---

## 3. Transactional Outbox Pattern

### 3.1 현재 상황 및 필요성

현재 `MemberPointBalance` 캐시 테이블은 **Spring Event + @TransactionalEventListener**를 사용하여 비동기로 업데이트됩니다.

| 구분     | 현재 상황               | 문제점                    |
|--------|---------------------|------------------------|
| 이벤트 저장 | 메모리 (인메모리)          | 애플리케이션 재시작 시 이벤트 유실    |
| 전달 보장  | At-most-once        | 이벤트 처리 실패 시 재시도 불가     |
| 분산 환경  | 단일 서버               | 다중 서버에서 이벤트 중복/유실 가능   |
| 장애 복구  | 불가                  | 장애 발생 시 유실된 이벤트 추적 어려움 |

### 3.2 Outbox Pattern 도입 시점

- 이벤트 유실이 허용되지 않는 운영 환경
- 캐시 테이블(`MemberPointBalance`)의 정합성이 중요한 경우
- 장애 복구 및 이벤트 재처리가 필요한 경우
- 이벤트 처리 이력 감사가 필요한 경우

### 3.3 현재 구현 vs Outbox Pattern

| 구분       | 현재 구현 (Spring Event)    | Outbox Pattern      |
|----------|-------------------------|---------------------|
| 이벤트 저장   | 메모리                     | **DB (Outbox 테이블)** |
| 트랜잭션 원자성 | 별도 트랜잭션                 | **동일 트랜잭션**         |
| 이벤트 유실   | **가능** (앱 재시작 시)        | **불가능**             |
| 전달 보장    | At-most-once            | **At-least-once**   |
| 재시도      | 수동 구현 필요                | **내장 지원**           |
| 순서 보장    | 보장 안됨                   | **보장 가능**           |
| 장애 복구    | 어려움                     | **용이**              |
| 구현 복잡도   | 낮음                      | 중간                  |

### 3.4 Outbox Pattern 개요

```
┌─────────────────────────────────────────────────────────────────┐
│ 서비스 트랜잭션 (하나의 원자적 트랜잭션)                                │
│                                                                 │
│  1. 포인트 적립 저장  →  point_accumulation 테이블                  │
│  2. 이벤트 저장       →  point_balance_outbox 테이블               │
│                                                                 │
│  [COMMIT] - 둘 다 성공하거나 둘 다 실패                              │
└─────────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│ 별도 프로세스 (폴링 또는 CDC)                                       │
│                                                                 │
│  1. Outbox 테이블에서 미처리 이벤트 조회                              │
│  2. 이벤트 처리 (MemberPointBalance 업데이트)                       │
│  3. 처리 완료 표시 / 실패 시 재시도 (최대 N회)                         │
└─────────────────────────────────────────────────────────────────┘
```

### 3.5 기대 효과

| 시나리오      | 현재 구현   | Outbox Pattern |
|-----------|---------|----------------|
| 이벤트 처리 성공 | ✅ 정상    | ✅ 정상           |
| 이벤트 처리 실패 | ❌ 유실    | ✅ 재시도          |
| 앱 재시작     | ❌ 유실    | ✅ 재처리          |
| DB 장애     | ❌ 유실    | ✅ 복구 후 재처리     |

### 3.6 Outbox 테이블 설계

| 컬럼             | 타입          | 설명                              |
|----------------|-------------|---------------------------------|
| id             | BIGINT (PK) | 자동 증가 식별자                       |
| aggregate_type | VARCHAR(50) | 집계 타입 (POINT_BALANCE)           |
| aggregate_id   | BIGINT      | 집계 식별자 (member_id)              |
| event_type     | VARCHAR(50) | 이벤트 타입 (ACCUMULATED, USED 등)    |
| payload        | JSON        | 이벤트 데이터                         |
| status         | VARCHAR(20) | 상태 (PENDING, PROCESSED, FAILED) |
| retry_count    | INT         | 재시도 횟수                          |
| max_retries    | INT         | 최대 재시도 횟수 (기본 3)                |
| error_message  | TEXT        | 실패 시 에러 메시지                     |
| created_at     | TIMESTAMP   | 생성 시간                           |
| processed_at   | TIMESTAMP   | 처리 완료 시간                        |

### 3.7 대안: Debezium CDC 방식

폴링 방식 대신 **Debezium CDC (Change Data Capture)**를 사용하면 더 효율적인 이벤트 처리가 가능합니다.

| 항목    | 폴링 방식       | CDC 방식 (Debezium)    |
|-------|-------------|----------------------|
| 처리 방식 | 주기적 DB 조회   | DB 로그 기반 실시간 감지      |
| 처리량   | 중간          | 높음                   |
| 지연 시간 | 폴링 주기에 의존   | 실시간                  |
| 인프라   | 단순 (DB만 필요) | 복잡 (Kafka, Debezium) |
| 운영 비용 | 낮음          | 높음                   |

### 3.8 도입 로드맵

| Phase            | 기간 | 작업 내용                          |
|------------------|----|--------------------------------|
| Phase 1: 기반 구축   | 1주 | Outbox 테이블 설계, 엔티티/리포지토리 구현    |
| Phase 2: 프로세서 구현 | 1주 | 폴링 프로세서 구현, 재시도/DLQ 처리         |
| Phase 3: 테스트/검증  | 1주 | 단위/통합 테스트, 장애 시나리오 테스트, 성능 테스트 |
| Phase 4: 운영 적용   | 1주 | 스테이징 검증, 운영 배포, 모니터링 구축        |

---

## 4. 기타 개선 사항

### 4.1 캐싱 전략

| 개선 항목       | 설명                    |
|-------------|-----------------------|
| Redis 캐시    | 회원 잔액 조회, 설정 값 캐싱     |
| TTL 기반 갱신   | 자동 캐시 무효화             |
| Cache-Aside | 캐시 미스 시 DB 조회 후 캐시 저장 |

### 4.2 비동기 처리

| 개선 항목        | 설명                     |
|--------------|------------------------|
| 이벤트 기반 아키텍처  | 포인트 적립/사용 이벤트 발행       |
| 알림 비동기 처리    | 이메일/푸시 알림 비동기 처리       |
| 메시지 큐        | Kafka/RabbitMQ 도입      |

### 4.3 읽기 성능 최적화

| 개선 항목        | 설명              |
|--------------|-----------------|
| CQRS 패턴      | 쓰기 모델과 읽기 모델 분리 |
| Read Replica | 읽기 전용 복제본 활용    |
| 인덱스 최적화      | 조회 쿼리 성능 개선     |

---

## 5. 결론

### 5.1 현재 구현 상태

| 기능     | 현재 구현                                      | 향후 개선                        |
|--------|--------------------------------------------|------------------------------|
| 동시성 제어 | JPA 비관적 락                                  | 분산 락 (Redis + Redisson)      |
| 이벤트 처리 | Spring Event + @TransactionalEventListener | Transactional Outbox Pattern |
| 잔액 조회  | 캐시 테이블 (MemberPointBalance)                | 유지 (Outbox로 정합성 강화)          |

### 5.2 권장 도입 순서

| Phase          | 환경        | 적용 기술                               |
|----------------|-----------|-------------------------------------|
| Phase 1-2 (현재) | 단일 서버     | 비관적 락, Spring Event, Reconciliation |
| Phase 3        | 서버 스케일 아웃 | 분산 락, Outbox Pattern                |
| Phase 4        | 대규모 트래픽   | Debezium CDC, Kafka                 |

### 5.3 의사결정 기준

```
                    트래픽 증가
                         │
         ┌───────────────┼───────────────┐
         ▼               ▼               ▼
   단일 서버 유지      서버 스케일 아웃     대규모 분산 환경
         │               │               │
         ▼               ▼               ▼
   현재 구현 유지      분산 락 도입        CDC + Kafka
                    Outbox Pattern
```

---

**이전 문서**: [10. 문서화 계획](./10-문서화-계획.md)
